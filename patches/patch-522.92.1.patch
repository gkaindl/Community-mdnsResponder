diff -rupN mDNSResponder-522.92.1/mDNSPosix/mDNSPosix.c mDNSResponder-522.92.1-Linux/mDNSPosix/mDNSPosix.c
--- mDNSResponder-522.92.1/mDNSPosix/mDNSPosix.c	2013-04-25 16:22:21.000000000 -0700
+++ mDNSResponder-522.92.1-Linux/mDNSPosix/mDNSPosix.c	2014-08-17 11:36:29.000000000 -0700
@@ -144,7 +144,7 @@ mDNSexport mStatus mDNSPlatformSendUDP(c
     PosixNetworkInterface * thisIntf = (PosixNetworkInterface *)(InterfaceID);
     int sendingsocket = -1;
 
-    (void)src;  // Will need to use this parameter once we implement mDNSPlatformUDPSocket/mDNSPlatformUDPClose
+    //(void)src;  // Will need to use this parameter once we implement mDNSPlatformUDPSocket/mDNSPlatformUDPClose
     (void) useBackgroundTrafficClass;
 
     assert(m != NULL);
@@ -166,7 +166,8 @@ mDNSexport mStatus mDNSPlatformSendUDP(c
         sin->sin_family         = AF_INET;
         sin->sin_port           = dstPort.NotAnInteger;
         sin->sin_addr.s_addr    = dst->ip.v4.NotAnInteger;
-        sendingsocket           = thisIntf ? thisIntf->multicastSocket4 : m->p->unicastSocket4;
+        sendingsocket           = (src) ? (src->sktv4) :
+                                      (thisIntf ? thisIntf->multicastSocket4 : m->p->unicastSocket4);
     }
 
 #if HAVE_IPV6
@@ -180,7 +181,8 @@ mDNSexport mStatus mDNSPlatformSendUDP(c
         sin6->sin6_family         = AF_INET6;
         sin6->sin6_port           = dstPort.NotAnInteger;
         sin6->sin6_addr           = *(struct in6_addr*)&dst->ip.v6;
-        sendingsocket             = thisIntf ? thisIntf->multicastSocket6 : m->p->unicastSocket6;
+        sendingsocket             = (src) ? (src->sktv6) :
+                                      (thisIntf ? thisIntf->multicastSocket6 : m->p->unicastSocket6);
     }
 #endif
 
@@ -210,7 +212,7 @@ mDNSexport mStatus mDNSPlatformSendUDP(c
 }
 
 // This routine is called when the main loop detects that data is available on a socket.
-mDNSlocal void SocketDataReady(mDNS *const m, PosixNetworkInterface *intf, int skt)
+mDNSlocal void SocketDataReady(mDNS *const m, PosixNetworkInterface *intf, int skt, mDNSIPPort localPort)
 {
     mDNSAddr senderAddr, destAddr;
     mDNSIPPort senderPort;
@@ -306,89 +308,477 @@ mDNSlocal void SocketDataReady(mDNS *con
 
     if (packetLen >= 0)
         mDNSCoreReceive(m, &packet, (mDNSu8 *)&packet + packetLen,
-                        &senderAddr, senderPort, &destAddr, MulticastDNSPort, InterfaceID);
+            &senderAddr, senderPort, &destAddr, mDNSIPPortIsZero(localPort) ? MulticastDNSPort : localPort, InterfaceID);
+
 }
 
 mDNSexport mDNSBool mDNSPlatformPeekUDP(mDNS *const m, UDPSocket *src)
 {
     (void)m;    // unused
     (void)src;  // unused
+    LogMsg("%s:%s(): NOT IMPLEMENTED!", __FILE__, __FUNCTION__);
     return mDNSfalse;
 }
 
+mDNSlocal mStatus SetupTCPSocket(TCPSocket *sock, u_short sa_family, mDNSIPPort *port)
+{
+   const int kOn = 1;  // "on" for setsockopt
+   mStatus err;
+
+   int skt = socket(sa_family, SOCK_STREAM, IPPROTO_TCP);
+   if (skt < 3) {
+      LogMsg("SetupTCPSocket: socket error %d errno %d (%s)", skt, errno, strerror(errno));
+      return mStatus_UnsupportedErr;
+   }
+
+   if (sa_family == AF_INET) {
+      // Bind it
+      struct sockaddr_in addr;
+      mDNSPlatformMemZero(&addr, sizeof(addr));
+      addr.sin_family = AF_INET;
+      addr.sin_port = port->NotAnInteger;
+
+      err = bind(skt, (struct sockaddr*) &addr, sizeof(addr));
+      if (err < 0) {
+         LogMsg("ERROR: SetupTCPSocket bind %s", strerror(errno));
+         return err;
+      }
+
+      // Receive interface identifiers
+    #if defined(IP_PKTINFO)                                 // Linux
+            err = setsockopt(skt, IPPROTO_IP, IP_PKTINFO, &kOn, sizeof(kOn));
+            if (err < 0) { err = errno; LogMsg("ERROR: SetupTCPSocket setsockopt - IP_PKTINFO"); }
+        #elif defined(IP_RECVDSTADDR) || defined(IP_RECVIF)     // BSD and Solaris
+            #if defined(IP_RECVDSTADDR)
+                err = setsockopt(skt, IPPROTO_IP, IP_RECVDSTADDR, &kOn, sizeof(kOn));
+                if (err < 0) { err = errno; LogMsg("ERROR: SetupTCPSocket setsockopt - IP_RECVDSTADDR"); }
+            #endif
+            #if defined(IP_RECVIF)
+                if (err == 0) {
+                    err = setsockopt(skt, IPPROTO_IP, IP_RECVIF, &kOn, sizeof(kOn));
+                    if (err < 0) { err = errno; LogMsg("ERROR: SetupTCPSocket setsockopt - IP_RECVIF"); }
+                }
+            #endif
+        #else
+            #warning This platform has no way to get the destination interface information -- will only work for single-homed hosts
+        #endif
+
+      mDNSPlatformMemZero(&addr, sizeof(addr));
+      socklen_t len = sizeof(addr);
+      err = getsockname(skt, (struct sockaddr*) &addr, &len);
+      if (err < 0) {
+         LogMsg("ERROR: SetupTCPSocket getsockname - %s", strerror(errno));
+         return err;
+      }
+
+      sock->sktv4 = skt;
+      port->NotAnInteger = addr.sin_port;
+#if HAVE_IPV6
+   } else {
+      // Bind it
+      struct sockaddr_in6 addr6;
+      mDNSPlatformMemZero(&addr6, sizeof(addr6));
+      addr6.sin6_family = AF_INET6;
+      addr6.sin6_port = port->NotAnInteger;
+
+      err = bind(skt, (struct sockaddr*) &addr6, sizeof(addr6));
+
+      if (err < 0) {
+         LogMsg("ERROR: SetupTCPSocket bind6 %s", strerror(errno));
+         return err;
+      }
+
+      // We want to receive destination addresses and receive interface identifiers
+      err = setsockopt(skt, IPPROTO_IPV6, IPV6_RECVPKTINFO, &kOn, sizeof(kOn));
+      if (err < 0) {
+         LogMsg("ERROR: SetupTCPSocket setsockopt IPV6_RECVPKTINFO %s", strerror(errno));
+         return err;
+      }
+
+      mDNSPlatformMemZero(&addr6, sizeof(addr6));
+      socklen_t len = sizeof(addr6);
+
+      err = getsockname(skt, (struct sockaddr *) &addr6, &len);
+      if (err < 0) {
+         LogMsg("ERROR: SetupTCPSocket getsockname6 - %s", strerror(errno));
+         return err;
+      }
+
+      sock->sktv6 = skt;
+      port->NotAnInteger = addr6.sin6_port;
+#endif
+   }
+
+   return mStatus_NoError;
+}
+
+mDNSlocal void DoTcpSocketCallback(TCPSocket *sock)
+{
+    mDNSBool c = !sock->state.connected;
+    sock->state.connected = 1;
+    sock->callback(sock, sock->context, c, sock->err);
+    // Note: the callback may call CloseConnection here, which frees the context structure!
+}
+
+
 mDNSexport TCPSocket *mDNSPlatformTCPSocket(mDNS * const m, TCPSocketFlags flags, mDNSIPPort * port, mDNSBool useBackgroundTrafficClass)
 {
-    (void)m;            // Unused
-    (void)flags;        // Unused
-    (void)port;         // Unused
-    (void)useBackgroundTrafficClass; // Unused
-    return NULL;
+    mStatus err;
+    
+   (void)m;
+    
+    TCPSocket *p = mallocL("TCPSocket", sizeof(TCPSocket));
+   if (!p) { LogMsg("mDNSPlatformTCPSocket: memory exhausted"); return(mDNSNULL); }
+   
+   mDNSPlatformMemZero(p, sizeof(TCPSocket));
+   p->sktv4 = -1;
+   p->sktv6 = -1;
+   p->activeSkt = -1;
+   
+   err = SetupTCPSocket(p, AF_INET, port);
+   
+#if HAVE_IPV6
+   if (mStatus_NoError == err) {
+      err = SetupTCPSocket(p, AF_INET6, port);
+      if (err) {
+         mDNSPlatformTCPCloseConnection(p);
+         p = NULL;
+      }
+   }
+#endif
+   
+   if (err) {
+      LogMsg("mDNSPlatformTCPSocket: socket error errno %d (%s)", errno, strerror(errno));
+      if (NULL != p)
+         freeL("TCPSocket/mDNSPlatformTCPSocket", p);
+      return(mDNSNULL);
+   }
+   
+   p->flags = flags;
+   
+   p->prev = NULL;
+   p->next = PlatformTCPSockets;
+   if (p->next)
+      p->next->prev = p;
+   PlatformTCPSockets = p;
+   
+   LogMsg("TCPSocket created for port %d, sock %d", port->NotAnInteger, p->sktv4);
+   
+   return p;
 }
 
+// Why doesn't mDNSPlatformTCPAccept actually call accept() ?
+// gck: Exactly what I was wondering too! :-)
 mDNSexport TCPSocket *mDNSPlatformTCPAccept(TCPSocketFlags flags, int sd)
 {
-    (void)flags;        // Unused
-    (void)sd;           // Unused
-    return NULL;
+   mStatus err = mStatus_NoError;
+
+   TCPSocket *sock = mallocL("TCPSocket/mDNSPlatformTCPAccept", sizeof(TCPSocket));
+   if (NULL == sock) {
+      LogMsg("mDNSPlatformTCPAccept: memory exhausted.");
+      return mDNSNULL;
+   }
+
+   mDNSPlatformMemZero(sock, sizeof(*sock));
+   sock->flags = flags;
+   sock->activeSkt = sd;
+   
+   // we need to find out if the connected socket is IPv4 or IPv6, since the
+   // function parameters won't tell us
+   struct sockaddr addr;
+   mDNSPlatformMemZero(&addr, sizeof(addr));
+    socklen_t len = sizeof(addr);
+   err = getsockname(sd, &addr, &len);
+   
+   if (AF_INET == addr.sa_family)
+      sock->sktv4 = sd;
+   else
+      sock->sktv6 = sd;
+
+   if (flags & kTCPSocketFlags_UseTLS) {
+      LogMsg("mDNSPlatformTCPAccept: ERROR kTCPSocketFlags_UseTLS not supported!");
+      err = mStatus_UnsupportedErr;
+   }
+   
+   if (err) {
+      freeL("TCPSocket/mDNSPlatformTCPAccept", sock);
+      sock = mDNSNULL;
+   }
+   
+   return sock;
 }
 
+mDNSlocal int GetFDTcp(TCPSocket *sock, u_short sa_family)
+{
+   return (AF_INET == sa_family) ? sock->sktv4 : sock->sktv6;
+} 
+
 mDNSexport int mDNSPlatformTCPGetFD(TCPSocket *sock)
 {
-    (void)sock;         // Unused
-    return -1;
+   // return the active socket, otherwise, return the IPv4 socket, else return IPv6
+   if (sock->activeSkt > -1)
+      return sock->activeSkt;
+   
+   int fd = GetFDTcp(sock, AF_INET);
+   
+   return (fd > -1) ? fd : GetFDTcp(sock, AF_INET6);
 }
 
-mDNSexport mStatus mDNSPlatformTCPConnect(TCPSocket *sock, const mDNSAddr *dst, mDNSOpaque16 dstport, domainname *hostname, mDNSInterfaceID InterfaceID,
-                                          TCPConnectionCallback callback, void *context)
+mDNSexport mStatus mDNSPlatformTCPConnect(TCPSocket *sock, const mDNSAddr *dst, mDNSOpaque16 dstport, domainname *hostname,
+                        mDNSInterfaceID InterfaceID, TCPConnectionCallback callback, void *context)
 {
-    (void)sock;         // Unused
-    (void)dst;          // Unused
-    (void)dstport;      // Unused
-    (void)hostname;     // Unused
-    (void)InterfaceID;  // Unused
-    (void)callback;     // Unused
-    (void)context;      // Unused
-    return(mStatus_UnsupportedErr);
+    struct sockaddr_storage ss;
+   
+#if HAVE_IPV6
+   int* s = (mDNSAddrType_IPv4 == dst->type) ? &sock->sktv4 : &sock->sktv6;
+#else
+   int* s = &sock->sktv4;
+#endif
+
+    sock->err         = mStatus_NoError;
+   sock->context     = context;
+   sock->callback    = callback;
+   
+   if (sock->state.connected)
+      LogMsg("mDNSPlatformTCPConnect: socket already connected!");
+
+    if (NULL != hostname) {
+       LogMsg("mDNSPlatformTCPConnect: hostname %##s", hostname->c);
+       AssignDomainName(&sock->hostname, hostname);
+    }
+
+    if (dst->type == mDNSAddrType_IPv4) {
+        struct sockaddr_in *saddr = (struct sockaddr_in *)&ss;
+        mDNSPlatformMemZero(saddr, sizeof(*saddr));
+        saddr->sin_family      = AF_INET;
+        saddr->sin_port        = dstport.NotAnInteger;
+        saddr->sin_addr.s_addr = dst->ip.v4.NotAnInteger;
+#ifndef NOT_HAVE_SA_LEN
+        saddr->sin_len         = sizeof(*saddr);
+#endif
+    } else {
+        struct sockaddr_in6 *saddr6 = (struct sockaddr_in6 *)&ss;
+        mDNSPlatformMemZero(saddr6, sizeof(*saddr6));
+        saddr6->sin6_family      = AF_INET6;
+        saddr6->sin6_port        = dstport.NotAnInteger;
+        saddr6->sin6_addr        = *(struct in6_addr *)&dst->ip.v6;
+#ifndef NOT_HAVE_SA_LEN
+        saddr6->sin6_len         = sizeof(*saddr6);
+#endif
+    }
+
+    if (fcntl(*s, F_SETFL, fcntl(*s, F_GETFL, 0) | O_NONBLOCK) < 0) { // set non-blocking
+        LogMsg("mDNSPlatformTCPConnect: ERROR setsockopt O_NONBLOCK - %s", strerror(errno));
+        return mStatus_UnknownErr;
+    }
+
+    // We bind to the interface and all subsequent packets including the SYN will be sent out
+    // on this interface
+    //
+    // Note: If we are in Active Directory domain, we may try TCP (if the response can't fit in
+    // UDP). mDNSInterface_Unicast indicates this case and not a valid interface.
+    if (InterfaceID && InterfaceID != mDNSInterface_Unicast) {
+       PosixNetworkInterface* intf = (PosixNetworkInterface *)(InterfaceID);
+       
+       // gck: SO_BINDTODEVICE is a linux-ism, but that's the only thing I'm concerned about here.
+       struct ifreq ifr;
+      memset(&ifr, 0, sizeof(struct ifreq));
+      strncpy(ifr.ifr_name, intf->intfName, sizeof(ifr.ifr_name));
+      ioctl(*s, SIOCGIFINDEX, &ifr);
+
+      int e = setsockopt(*s, SOL_SOCKET, SO_BINDTODEVICE, (void*)&ifr, sizeof(struct ifreq));
+      LogMsg("mDNSPlatformTCPConnect: binding to device %s returned %d", ifr.ifr_name, e);
+    }
+
+   sock->activeSkt = *s;
+
+   if (connect(*s, (struct sockaddr*)&ss, sizeof(struct sockaddr)) < 0) {
+      switch (errno) {
+         case EINPROGRESS:
+            return mStatus_ConnPending;
+         default:
+            LogMsg("ERROR: mDNSPlatformTCPConnect - connect failed: socket %d: Error %d (%s)", *s, errno, strerror(errno));
+            return mStatus_ConnFailed;
+      }
+   }
+   
+   LogMsg("NOTE: mDNSPlatformTCPConnect completed synchronously");
+   return mStatus_NoError;
 }
 
 mDNSexport void mDNSPlatformTCPCloseConnection(TCPSocket *sock)
 {
-    (void)sock;         // Unused
+   if (sock) {
+      if (sock->activeSkt > -1) close(sock->activeSkt);
+      if (sock->sktv4 > -1) close(sock->sktv4);
+#if HAVE_IPV6
+      if (sock->sktv6 > -1) close(sock->sktv6);
+#endif
+
+      if (sock->prev)
+         sock->prev->next = sock->next;
+      else
+         PlatformTCPSockets = sock->next;
+
+      if (sock->next)
+         sock->next->prev = sock->prev;
+
+      LogMsg("Closed TCP socket %d", sock->sktv4);
+
+      freeL("TCPSocket/mDNSPlatformTCPCloseConnection", sock);
+   }
 }
 
 mDNSexport long mDNSPlatformReadTCP(TCPSocket *sock, void *buf, unsigned long buflen, mDNSBool * closed)
 {
-    (void)sock;         // Unused
-    (void)buf;          // Unused
-    (void)buflen;       // Unused
-    (void)closed;       // Unused
-    return 0;
+   size_t nread = 0;
+   int fd = (sock->activeSkt > -1) ? sock->activeSkt : mDNSPlatformTCPGetFD(sock);
+   
+   if (NULL != closed)
+      *closed = mDNSfalse;
+    
+    if (sock->flags & kTCPSocketFlags_UseTLS) {
+      LogMsg("ERROR: mDNSPlatformReadTCP kTCPSocketFlags_UseTLS not supported!");
+      nread = -1;
+      if (NULL != closed)
+         *closed = mDNStrue;
+    } else {
+      static int CLOSEDcount = 0;
+      static int EAGAINcount = 0;
+      
+      nread = recv(fd, buf, buflen, 0);
+      
+      if (nread > 0) {
+         CLOSEDcount = EAGAINcount = 0;
+      } else if (0 == nread) {
+         if (NULL != closed)
+            *closed = mDNStrue;
+         if ((++CLOSEDcount % 1000) == 0)
+            LogMsg("ERROR: mDNSPlatformReadTCP - recv %d got CLOSED %d times", sock->activeSkt, CLOSEDcount);
+      } else if (ECONNRESET == errno) {   // from here on, nread must be negative
+         nread = 0;
+         if (NULL != closed)
+            *closed = mDNStrue;
+      } else if (EAGAIN == errno) {
+         nread = 0;
+         if ((++EAGAINcount % 1000) == 0)
+            LogMsg("ERROR: mDNSPlatformReadTCP - recv %d got EAGAIN %d times", sock->activeSkt, EAGAINcount);
+      } else {
+         nread = -1;
+         LogMsg("ERROR: mDNSPlatformReadTCP - recv: %d (%s)", errno, strerror(errno));
+      }
+    }
+
+   return nread;
 }
 
 mDNSexport long mDNSPlatformWriteTCP(TCPSocket *sock, const char *msg, unsigned long len)
 {
-    (void)sock;         // Unused
-    (void)msg;          // Unused
-    (void)len;          // Unused
-    return 0;
-}
+   int nsent;
+   int fd = (sock->activeSkt > -1) ? sock->activeSkt : mDNSPlatformTCPGetFD(sock);
 
-mDNSexport UDPSocket *mDNSPlatformUDPSocket(mDNS * const m, mDNSIPPort port)
-{
-    (void)m;            // Unused
-    (void)port;         // Unused
-    return NULL;
+   if (sock->flags & kTCPSocketFlags_UseTLS) {
+      LogMsg("ERROR: mDNSPlatformWriteTCP kTCPSocketFlags_UseTLS not supported!");
+      nsent = -1;
+   } else {
+      nsent = send(fd, msg, len, 0);
+      
+      if (nsent < 0) {
+         if (EAGAIN == errno)
+            nsent = 0;
+         else {
+            LogMsg("ERROR: mDNSPlatformWriteTCP - send %s", strerror(errno));
+            nsent = -1;
+         }
+      }
+   }
+   
+   return nsent;
 }
 
-mDNSexport void           mDNSPlatformUDPClose(UDPSocket *sock)
+mDNSexport UDPSocket *mDNSPlatformUDPSocket(mDNS * const m, mDNSIPPort port)
 {
-    (void)sock;         // Unused
+   mStatus err;
+   mDNSIPPort port = port;
+   mDNSBool randomizePort = mDNSIPPortIsZero(port);
+   struct sockaddr sa;
+   int i = 1000; // Try at most 1000 times to get a unique random port
+   UDPSocket *p = mallocL("UDPSocket", sizeof(UDPSocket));
+   if (!p) { LogMsg("mDNSPlatformUDPSocket: memory exhausted"); return(mDNSNULL); }
+   mDNSPlatformMemZero(p, sizeof(UDPSocket));
+   p->port  = zeroIPPort;
+   p->sktv4 = -1;
+   p->sktv6 = -1;
+
+   (void)m;
+
+   do
+    {
+    // The kernel doesn't do cryptographically strong random port allocation, so we do it ourselves here
+    if (randomizePort) port = mDNSOpaque16fromIntVal(0xC000 + mDNSRandom(0x3FFF));
+      mDNSPlatformMemZero(&sa, sizeof(struct sockaddr));
+      sa.sa_family = AF_INET;
+    err = SetupSocket(&sa, port, 0, &p->sktv4, &p->port, mDNSSameIPPort(port, NATPMPAnnouncementPort));
+    /* TODO: make me work!
+    if (!err)
+        {
+           mDNSPlatformMemZero(&sa, sizeof(struct sockaddr));
+         sa.sa_family = AF_INET6;
+        err = SetupSocket(&sa, port, 0, &p->sktv6, &p->port, 0);
+        if (err) { close(p->sktv4); p->sktv4 = -1; }
+        }*/
+    i--;
+    } while (err == EADDRINUSE && randomizePort && i);
+
+   if (err)
+    {
+    // In customer builds we don't want to log failures with port 5351, because this is a known issue
+    // of failing to bind to this port when Internet Sharing has already bound to it
+    // We also don't want to log about port 5350, due to a known bug when some other
+    // process is bound to it.
+    if (mDNSSameIPPort(port, NATPMPPort) || mDNSSameIPPort(port, NATPMPAnnouncementPort))
+        LogInfo("mDNSPlatformUDPSocket: SetupSocket %d failed error %d errno %d (%s)", mDNSVal16(port), err, errno, strerror(errno));
+    else LogMsg("mDNSPlatformUDPSocket: SetupSocket %d failed error %d errno %d (%s)", mDNSVal16(port), err, errno, strerror(errno));
+    freeL("UDPSocket", p);
+    return(mDNSNULL);
+    }
+   
+   p->prev = NULL;
+   p->next = PlatformUDPSockets;
+   if (p->next)
+      p->next->prev = p;
+   PlatformUDPSockets = p;
+   
+   return(p);
+}
+
+mDNSexport void mDNSPlatformUDPClose(UDPSocket *sock)
+{
+   if (sock->sktv4 > -1) {
+      close(sock->sktv4);
+      sock->sktv4 = -1;
+   }
+   if (sock->sktv6 > -1) {
+      close(sock->sktv6);
+      sock->sktv6 = -1;
+   }
+   
+   if (sock->prev)
+      sock->prev->next = sock->next;
+   else
+      PlatformUDPSockets = sock->next;
+   
+   if (sock->next)
+      sock->next->prev = sock->prev;
+   
+   freeL("UDPSocket", sock);
 }
 
 mDNSexport void mDNSPlatformUpdateProxyList(mDNS *const m, const mDNSInterfaceID InterfaceID)
 {
     (void)m;            // Unused
     (void)InterfaceID;          // Unused
+    LogMsg("%s:%s(): NOT IMPLEMENTED!", __FILE__, __FUNCTION__);
 }
 
 mDNSexport void mDNSPlatformSendRawPacket(const void *const msg, const mDNSu8 *const end, mDNSInterfaceID InterfaceID)
@@ -396,6 +786,7 @@ mDNSexport void mDNSPlatformSendRawPacke
     (void)msg;          // Unused
     (void)end;          // Unused
     (void)InterfaceID;          // Unused
+    LogMsg("%s:%s(): NOT IMPLEMENTED!", __FILE__, __FUNCTION__);
 }
 
 mDNSexport void mDNSPlatformSetLocalAddressCacheEntry(mDNS *const m, const mDNSAddr *const tpa, const mDNSEthAddr *const tha, mDNSInterfaceID InterfaceID)
@@ -404,15 +795,18 @@ mDNSexport void mDNSPlatformSetLocalAddr
     (void)tpa;          // Unused
     (void)tha;          // Unused
     (void)InterfaceID;          // Unused
+    LogMsg("%s:%s(): NOT IMPLEMENTED!", __FILE__, __FUNCTION__);
 }
 
 mDNSexport mStatus mDNSPlatformTLSSetupCerts(void)
 {
+    LogMsg("%s:%s(): NOT IMPLEMENTED!", __FILE__, __FUNCTION__);
     return(mStatus_UnsupportedErr);
 }
 
 mDNSexport void mDNSPlatformTLSTearDownCerts(void)
 {
+    LogMsg("%s:%s(): NOT IMPLEMENTED!", __FILE__, __FUNCTION__);
 }
 
 mDNSexport void mDNSPlatformSetAllowSleep(mDNS *const m, mDNSBool allowSleep, const char *reason)
@@ -420,6 +814,7 @@ mDNSexport void mDNSPlatformSetAllowSlee
     (void) m;
     (void) allowSleep;
     (void) reason;
+    LogMsg("%s:%s(): NOT IMPLEMENTED!", __FILE__, __FUNCTION__);
 }
 
 #if COMPILER_LIKES_PRAGMA_MARK
@@ -453,20 +848,108 @@ mDNSexport mDNSBool mDNSPlatformSetDNSCo
     return mDNStrue;
 }
 
+#ifdef TARGET_OS_LINUX
+#include <ctype.h>
+#endif
+
 mDNSexport mStatus mDNSPlatformGetPrimaryInterface(mDNS * const m, mDNSAddr * v4, mDNSAddr * v6, mDNSAddr * router)
+#ifdef TARGET_OS_LINUX
 {
+   unsigned long d, g;
+   char buf[256];
+   int line = 0;
+   FILE * f;
+   char * p;
+
+   (void)m;
+
+   // TODO: where/how to get ipv6 address?
+   if (v6)
+      *v6 = zeroAddr;
+
+   f = fopen("/proc/net/route", "r");
+
+   if (!f)
+      return mStatus_UnknownErr;
+
+   while(fgets(buf, sizeof(buf), f)) {
+      if(line > 0) {  /* skip the first line */
+         p = buf;
+
+         /* skip the interface name */
+         while(*p && !isspace(*p))
+            p++;
+
+         *p++ = '\0';
+
+         while(*p && isspace(*p))
+            p++;
+
+         if(sscanf(p, "%lx%lx", &d, &g)==2) {
+            if(d == 0 && g != 0) {
+               if (router) {
+                  router->type = mDNSAddrType_IPv4;
+                  router->ip.v4.NotAnInteger = g;
+               }
+               fclose(f);
+               
+               int sock = socket(AF_INET, SOCK_DGRAM, 0);
+               if (sock > -1) {
+                  struct sockaddr_in sin;
+                  socklen_t socklen = sizeof(struct sockaddr_in);
+                  
+                  mDNSPlatformMemZero(&sin, socklen);
+                  sin.sin_port = htons(3000);
+                  sin.sin_addr.s_addr = INADDR_ANY;
+                  sin.sin_family = AF_INET;
+                  
+                  
+                  if (connect(sock, (struct sockaddr*)&sin, socklen) >= 0 &&
+                      getsockname(sock, (struct sockaddr*)&sin, &socklen) >= 0) {
+                     
+                     if (v4) {
+                        v4->type = mDNSAddrType_IPv4;
+                        v4->ip.v4.NotAnInteger = sin.sin_addr.s_addr;
+                     }
+                     
+                     return mStatus_NoError;
+                  }
+                  
+                  close(sock);
+               }
+               
+               return mStatus_UnknownErr;
+            }
+         }
+      }
+
+   line++;
+   }
+
+   /* default route not found ! */
+   if (f)
+      fclose(f);
+
+   return mStatus_UnknownErr;
+}
+#else
+    {
     (void) m;
     (void) v4;
     (void) v6;
     (void) router;
 
+   LogMsg("%s:%s(): NOT IMPLEMENTED!", __FILE__, __FUNCTION__);
+
     return mStatus_UnsupportedErr;
-}
+    }
+#endif
 
 mDNSexport void mDNSPlatformDynDNSHostNameStatusChanged(const domainname *const dname, const mStatus status)
 {
     (void) dname;
     (void) status;
+    LogMsg("%s:%s(): NOT IMPLEMENTED!", __FILE__, __FUNCTION__);
 }
 
 #if COMPILER_LIKES_PRAGMA_MARK
@@ -601,13 +1084,15 @@ mDNSlocal void ClearInterfaceList(mDNS *
 // Sets up a send/receive socket.
 // If mDNSIPPort port is non-zero, then it's a multicast socket on the specified interface
 // If mDNSIPPort port is zero, then it's a randomly assigned port number, used for sending unicast queries
-mDNSlocal int SetupSocket(struct sockaddr *intfAddr, mDNSIPPort port, int interfaceIndex, int *sktPtr)
+mDNSlocal int SetupSocket(struct sockaddr *intfAddr, mDNSIPPort port, int interfaceIndex, int *sktPtr,
+                           mDNSIPPort* outport, mDNSBool joinMC)
 {
     int err = 0;
     static const int kOn = 1;
     static const int kIntTwoFiveFive = 255;
     static const unsigned char kByteTwoFiveFive = 255;
-    const mDNSBool JoinMulticastGroup = (port.NotAnInteger != 0);
+    const mDNSBool JoinMulticastGroup = joinMC; // was: (port.NotAnInteger != 0);
+    const mDNSBool isNATPMPAnnouncePort = mDNSSameIPPort(port, NATPMPAnnouncementPort);
 
     (void) interfaceIndex;  // This parameter unused on plaforms that don't have IPv6
     assert(intfAddr != NULL);
@@ -673,7 +1158,8 @@ mDNSlocal int SetupSocket(struct sockadd
         // Add multicast group membership on this interface
         if (err == 0 && JoinMulticastGroup)
         {
-            imr.imr_multiaddr.s_addr = AllDNSLinkGroup_v4.ip.v4.NotAnInteger;
+            imr.imr_multiaddr.s_addr = isNATPMPAnnouncePort ? AllHosts_v4.NotAnInteger :  
+                                          AllDNSLinkGroup_v4.ip.v4.NotAnInteger;
             imr.imr_interface        = ((struct sockaddr_in*)intfAddr)->sin_addr;
             err = setsockopt(*sktPtr, IPPROTO_IP, IP_ADD_MEMBERSHIP, &imr, sizeof(imr));
             if (err < 0) { err = errno; perror("setsockopt - IP_ADD_MEMBERSHIP"); }
@@ -708,9 +1194,10 @@ mDNSlocal int SetupSocket(struct sockadd
         {
             bindAddr.sin_family      = AF_INET;
             bindAddr.sin_port        = port.NotAnInteger;
-            bindAddr.sin_addr.s_addr = INADDR_ANY; // Want to receive multicasts AND unicasts on this socket
+            bindAddr.sin_addr.s_addr = isNATPMPAnnouncePort ? AllHosts_v4.NotAnInteger : INADDR_ANY; // Want to receive multicasts AND unicasts on this socket
             err = bind(*sktPtr, (struct sockaddr *) &bindAddr, sizeof(bindAddr));
             if (err < 0) { err = errno; perror("bind"); fflush(stderr); }
+            if (outport) outport->NotAnInteger = bindAddr.sin_port;
         }
     }     // endif (intfAddr->sa_family == AF_INET)
 
@@ -875,10 +1362,10 @@ mDNSlocal int SetupOneInterface(mDNS *co
     if (err == 0)
     {
         if (alias->multicastSocket4 == -1 && intfAddr->sa_family == AF_INET)
-            err = SetupSocket(intfAddr, MulticastDNSPort, intf->index, &alias->multicastSocket4);
+            err = SetupSocket(intfAddr, MulticastDNSPort, intf->index, &alias->multicastSocket4, NULL, 1);
 #if HAVE_IPV6
         else if (alias->multicastSocket6 == -1 && intfAddr->sa_family == AF_INET6)
-            err = SetupSocket(intfAddr, MulticastDNSPort, intf->index, &alias->multicastSocket6);
+            err = SetupSocket(intfAddr, MulticastDNSPort, intf->index, &alias->multicastSocket6, NULL, 1);
 #endif
     }
 
@@ -1236,11 +1723,11 @@ mDNSexport mStatus mDNSPlatformInit(mDNS
 
     sa.sa_family = AF_INET;
     m->p->unicastSocket4 = -1;
-    if (err == mStatus_NoError) err = SetupSocket(&sa, zeroIPPort, 0, &m->p->unicastSocket4);
+    if (err == mStatus_NoError) err = SetupSocket(&sa, zeroIPPort, 0, &m->p->unicastSocket4, NULL, 0);
 #if HAVE_IPV6
     sa.sa_family = AF_INET6;
     m->p->unicastSocket6 = -1;
-    if (err == mStatus_NoError) err = SetupSocket(&sa, zeroIPPort, 0, &m->p->unicastSocket6);
+    if (err == mStatus_NoError) err = SetupSocket(&sa, zeroIPPort, 0, &m->p->unicastSocket6, NULL, 0);
 #endif
 
     // Tell mDNS core about the network interfaces on this machine.
@@ -1590,6 +2077,24 @@ mDNSexport void mDNSPosixGetFDSet(mDNS *
         info = (PosixNetworkInterface *)(info->coreIntf.next);
     }
 
+    UDPSocket* udpSock = PlatformUDPSockets;
+    while (udpSock) {
+        if (udpSock->sktv4 > -1) mDNSPosixAddToFDSet(nfds, readfds, udpSock->sktv4);
+#if HAVE_IPV6
+        if (udpSock->sktv6 > -1) mDNSPosixAddToFDSet(nfds, readfds, udpSock->sktv6);
+#endif
+      
+        udpSock = udpSock->next;
+    }
+   
+    TCPSocket* tcpSock = PlatformTCPSockets;
+    while (tcpSock) {
+        int fd = mDNSPlatformTCPGetFD(tcpSock);
+        if (fd > -1) mDNSPosixAddToFDSet(nfds, readfds, fd);
+
+        tcpSock = tcpSock->next;
+    }
+
     // 3. Calculate the time remaining to the next scheduled event (in struct timeval format)
     ticks = nextevent - mDNS_TimeNow(m);
     if (ticks < 1) ticks = 1;
@@ -1612,13 +2117,13 @@ mDNSexport void mDNSPosixProcessFDSet(mD
     if (m->p->unicastSocket4 != -1 && FD_ISSET(m->p->unicastSocket4, readfds))
     {
         FD_CLR(m->p->unicastSocket4, readfds);
-        SocketDataReady(m, NULL, m->p->unicastSocket4);
+        SocketDataReady(m, NULL, m->p->unicastSocket4, zeroIPPort);
     }
 #if HAVE_IPV6
     if (m->p->unicastSocket6 != -1 && FD_ISSET(m->p->unicastSocket6, readfds))
     {
         FD_CLR(m->p->unicastSocket6, readfds);
-        SocketDataReady(m, NULL, m->p->unicastSocket6);
+        SocketDataReady(m, NULL, m->p->unicastSocket6, zeroIPPort);
     }
 #endif
 
@@ -1627,17 +2132,49 @@ mDNSexport void mDNSPosixProcessFDSet(mD
         if (info->multicastSocket4 != -1 && FD_ISSET(info->multicastSocket4, readfds))
         {
             FD_CLR(info->multicastSocket4, readfds);
-            SocketDataReady(m, info, info->multicastSocket4);
+            SocketDataReady(m, info, info->multicastSocket4, zeroIPPort);
         }
 #if HAVE_IPV6
         if (info->multicastSocket6 != -1 && FD_ISSET(info->multicastSocket6, readfds))
         {
             FD_CLR(info->multicastSocket6, readfds);
-            SocketDataReady(m, info, info->multicastSocket6);
+            SocketDataReady(m, info, info->multicastSocket6, zeroIPPort);
         }
 #endif
         info = (PosixNetworkInterface *)(info->coreIntf.next);
     }
+    UDPSocket* udpSock = PlatformUDPSockets;
+    while (udpSock) {
+        if (udpSock->sktv4 > -1 && FD_ISSET(udpSock->sktv4, readfds)) {
+            FD_CLR(udpSock->sktv4, readfds);
+            SocketDataReady(m, NULL, udpSock->sktv4, udpSock->port);
+        }
+#if HAVE_IPV6
+        if (udpSock->sktv6 > -1 && FD_ISSET(udpSock->sktv6, readfds)) {
+            FD_CLR(udpSock->sktv6, readfds);
+            SocketDataReady(m, NULL, udpSock->sktv6, udpSock->port);
+        }
+#endif
+
+        udpSock = udpSock->next;
+    }
+      
+    TCPSocket* tcpSock = PlatformTCPSockets;
+    while (tcpSock) {
+        int fd = mDNSPlatformTCPGetFD(tcpSock);
+        if (fd > -1 && FD_ISSET(fd, readfds)) {
+            FD_CLR(fd, readfds);
+            
+            if (tcpSock->flags & kTCPSocketFlags_UseTLS) {
+               LogMsg("ERROR: mDNSPosixProcessFDSet kTCPSocketFlags_UseTLS not supported!");
+               tcpSock->err = mStatus_UnsupportedErr;
+            }
+            
+            DoTcpSocketCallback(tcpSock);
+        }
+
+        tcpSock = tcpSock->next;
+    }
 }
 
 // update gMaxFD
@@ -1778,3 +2315,70 @@ mStatus mDNSPosixRunEventLoopOnce(mDNS *
 
     return mStatus_NoError;
 }
+
+#ifdef TARGET_OS_LINUX
+int mDNS_PlatformGetGateway(const char* ifname, mDNSAddr* v4, mDNSAddr* v6)
+{
+    unsigned long d, g;
+    char buf[256];
+    int line = 0;
+    FILE * f;
+    char * p;
+
+    // TODO: how to get v6 address?
+    if (v6)
+        *v6 = zeroAddr;
+
+    f = fopen("/proc/net/route", "r");
+
+    if (!f)
+        return mStatus_UnknownErr;
+
+    while(fgets(buf, sizeof(buf), f)) {
+        if(line > 0) {  /* skip the first line */
+            p = buf;
+
+            /* skip the interface name */
+            while(*p && !isspace(*p))
+                p++;
+
+            if (ifname) {
+                *p = '\0';
+                if (strcmp(ifname, buf))
+                    continue;
+                else
+                    *p = ' ';
+            }
+
+            while(*p && isspace(*p))
+                p++;
+
+            // TODO: how to actually get the router address if it's NOT the
+            // default route (e.g. 0.0.0.0)
+            if(sscanf(p, "%lx%lx", &d, &g)==2) {
+                if(d == 0 && g != 0) { /* default */
+                    if (v4) {
+                        v4->type = mDNSAddrType_IPv4;
+                        v4->ip.v4.NotAnInteger = g;
+                    }
+                    fclose(f);
+                    return mStatus_NoError;
+                }
+            }
+        }
+
+    line++;
+    }
+
+    /* default route not found ! */
+    if (f)
+        fclose(f);
+
+return mStatus_UnknownErr;
+}
+#else
+int mDNS_PlatformGetGateway(const char* ifname, in_addr_t * addr)
+{
+    return -1;
+}
+#endif
diff -rupN mDNSResponder-522.92.1/mDNSShared/PlatformCommon.c mDNSResponder-522.92.1-Linux/mDNSShared/PlatformCommon.c
--- mDNSResponder-522.92.1/mDNSShared/PlatformCommon.c	2012-06-29 21:52:35.000000000 -0700
+++ mDNSResponder-522.92.1-Linux/mDNSShared/PlatformCommon.c	2014-08-17 11:42:42.000000000 -0700
@@ -21,6 +21,7 @@
 #include <errno.h>              // Needed for errno etc.
 #include <sys/socket.h>         // Needed for socket() etc.
 #include <netinet/in.h>         // Needed for sockaddr_in
+#include <stdlib.h>             // Needed for strtol()
 #include <syslog.h>
 
 #include "mDNSEmbeddedAPI.h"    // Defines the interface provided to the client layer above
@@ -102,20 +103,32 @@ mDNSlocal mDNSBool GetConfigOption(char 
 mDNSexport void ReadDDNSSettingsFromConfFile(mDNS *const m, const char *const filename, domainname *const hostname, domainname *const domain, mDNSBool *DomainDiscoveryDisabled)
 {
     char buf[MAX_ESCAPED_DOMAIN_NAME] = "";
+    char knn[MAX_ESCAPED_DOMAIN_NAME] = "";
+    domainname keyName;
+    mDNSIPPort port;
+    keyName.c[0] = knn[0] = 0;
+
     mStatus err;
     FILE *f = fopen(filename, "r");
 
     if (hostname) hostname->c[0] = 0;
     if (domain) domain->c[0] = 0;
     if (DomainDiscoveryDisabled) *DomainDiscoveryDisabled = mDNSfalse;
+    
+    port = UnicastDNSPort;
 
     if (f)
     {
         if (DomainDiscoveryDisabled && GetConfigOption(buf, "DomainDiscoveryDisabled", f) && !strcasecmp(buf, "true")) *DomainDiscoveryDisabled = mDNStrue;
         if (hostname && GetConfigOption(buf, "hostname", f) && !MakeDomainNameFromDNSNameString(hostname, buf)) goto badf;
         if (domain && GetConfigOption(buf, "zone", f) && !MakeDomainNameFromDNSNameString(domain, buf)) goto badf;
+        if (GetConfigOption(buf, "port", f)) {
+            port = mDNSOpaque16fromIntVal(strtol(buf, (char **)NULL, 10));
+        }
         buf[0] = 0;
         GetConfigOption(buf, "secret-64", f);  // failure means no authentication
+        if (GetConfigOption(knn, "secret-name", f))
+            MakeDomainNameFromDNSNameString(&keyName, knn);
         fclose(f);
         f = NULL;
     }
@@ -129,7 +142,7 @@ mDNSexport void ReadDDNSSettingsFromConf
     {
         DomainAuthInfo *info = (DomainAuthInfo*)mDNSPlatformMemAllocate(sizeof(*info));
         // for now we assume keyname = service reg domain and we use same key for service and hostname registration
-        err = mDNS_SetSecretForDomain(m, info, domain, domain, buf, NULL, 0, mDNSfalse);
+        err = mDNS_SetSecretForDomain(m, info, domain, (keyName.c[0] ? &keyName : domain), buf, hostname, &port, NULL);
         if (err) LogMsg("ERROR: mDNS_SetSecretForDomain returned %d for domain %##s", err, domain->c);
     }
 
diff -rupN mDNSResponder-522.92.1/mDNSShared/dnsextd.c mDNSResponder-522.92.1-Linux/mDNSShared/dnsextd.c
--- mDNSResponder-522.92.1/mDNSShared/dnsextd.c	2013-04-25 16:22:21.000000000 -0700
+++ mDNSResponder-522.92.1-Linux/mDNSShared/dnsextd.c	2014-08-17 11:46:25.000000000 -0700
@@ -1240,8 +1240,8 @@ SetupSockets
 
     // set up socket on which we receive private requests
 
-    self->llq_tcpsd = socket( AF_INET, SOCK_STREAM, 0 );
-    require_action( dnssd_SocketValid(self->tlssd), exit, err = mStatus_UnknownErr; LogErr( "SetupSockets", "socket" ) );
+    //self->llq_tcpsd = socket( AF_INET, SOCK_STREAM, 0 );
+    //require_action( dnssd_SocketValid(self->tlssd), exit, err = mStatus_UnknownErr; LogErr( "SetupSockets", "socket" ) );
     mDNSPlatformMemZero(&daddr, sizeof(daddr));
     daddr.sin_family        = AF_INET;
     daddr.sin_addr.s_addr   = zerov4Addr.NotAnInteger;

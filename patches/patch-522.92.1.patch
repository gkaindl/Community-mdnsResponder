diff -rupN mDNSResponder-522.92.1/mDNSPosix/Identify.c mDNSResponder-522.92.1-Linux/mDNSPosix/Identify.c
--- mDNSResponder-522.92.1/mDNSPosix/Identify.c	2013-02-13 19:00:18.000000000 -0800
+++ mDNSResponder-522.92.1-Linux/mDNSPosix/Identify.c	2014-08-17 13:21:32.000000000 -0700
@@ -22,8 +22,10 @@
 // We want to use the functionality provided by "mDNS.c",
 // except we'll sneak a peek at the packets before forwarding them to the normal mDNSCoreReceive() routine
 #define mDNSCoreReceive __MDNS__mDNSCoreReceive
+#define UDPSocket_struct __UDPSocket_struct
 #include "mDNS.c"
 #undef mDNSCoreReceive
+#undef UDPSocket_struct
 
 //*************************************************************************************************************
 // Headers
diff -rupN mDNSResponder-522.92.1/mDNSPosix/NetMonitor.c mDNSResponder-522.92.1-Linux/mDNSPosix/NetMonitor.c
--- mDNSResponder-522.92.1/mDNSPosix/NetMonitor.c	2012-11-15 14:56:09.000000000 -0800
+++ mDNSResponder-522.92.1-Linux/mDNSPosix/NetMonitor.c	2014-08-17 13:21:32.000000000 -0700
@@ -22,8 +22,10 @@
 // We want to use much of the functionality provided by "mDNS.c",
 // except we'll steal the packets that would be sent to normal mDNSCoreReceive() routine
 #define mDNSCoreReceive __NOT__mDNSCoreReceive__NOT__
+#define UDPSocket_struct __UDPSocket_struct
 #include "mDNS.c"
 #undef mDNSCoreReceive
+#undef UDPSocket_struct
 
 //*************************************************************************************************************
 // Headers
diff -rupN mDNSResponder-522.92.1/mDNSPosix/PosixDaemon.c mDNSResponder-522.92.1-Linux/mDNSPosix/PosixDaemon.c
--- mDNSResponder-522.92.1/mDNSPosix/PosixDaemon.c	2011-12-01 16:39:45.000000000 -0800
+++ mDNSResponder-522.92.1-Linux/mDNSPosix/PosixDaemon.c	2014-08-17 13:21:32.000000000 -0700
@@ -50,6 +50,12 @@ extern int daemon(int, int);
 #include "PlatformCommon.h"
 
 #define CONFIG_FILE "/etc/mdnsd.conf"
+
+// service registration
+#define SERVICES_FILE "/etc/mdnsd-services.conf"
+static mStatus RegisterServicesInFile(const char *filePath);
+static void DeregisterOurServices(void);
+
 static domainname DynDNSZone;                // Default wide-area zone for service registration
 static domainname DynDNSHostname;
 
@@ -88,13 +94,18 @@ static void Reconfigure(mDNS *m)
 {
     mDNSAddr DynDNSIP;
     const mDNSAddr dummy = { mDNSAddrType_IPv4, { { { 1, 1, 1, 1 } } } };;
+    mDNSAddr router;
     mDNS_SetPrimaryInterfaceInfo(m, NULL, NULL, NULL);
     if (ParseDNSServers(m, uDNS_SERVERS_FILE) < 0)
         LogMsg("Unable to parse DNS server list. Unicast DNS-SD unavailable");
     ReadDDNSSettingsFromConfFile(m, CONFIG_FILE, &DynDNSHostname, &DynDNSZone, NULL);
     mDNSPlatformSourceAddrForDest(&DynDNSIP, &dummy);
     if (DynDNSHostname.c[0]) mDNS_AddDynDNSHostName(m, &DynDNSHostname, NULL, NULL);
-    if (DynDNSIP.type) mDNS_SetPrimaryInterfaceInfo(m, &DynDNSIP, NULL, NULL);
+    if (DynDNSIP.type) {
+        int r = mDNS_PlatformGetGateway(NULL, &router, NULL);
+        mDNS_SetPrimaryInterfaceInfo(m, &DynDNSIP, NULL, (mStatus_NoError == r) ? &router : NULL);
+    }
+
     mDNS_ConfigChanged(m);
 }
 
@@ -194,9 +205,14 @@ int main(int argc, char **argv)
             LogMsg("WARNING: mdnsd continuing as root because user \"nobody\" does not exist");
     }
 
+    if(mStatus_NoError != RegisterServicesInFile(SERVICES_FILE))
+        LogMsg("Failed to register (some) services from %s.", SERVICES_FILE);
+
     if (mStatus_NoError == err)
         err = MainLoop(&mDNSStorage);
 
+    DeregisterOurServices();
+
     LogMsg("%s stopping", mDNSResponderVersionString);
 
     mDNS_Close(&mDNSStorage);
@@ -242,6 +258,325 @@ mDNSexport void RecordUpdatedNiceLabel(m
     // No-op, for now
 }
 
+// registering services from config file
+
+#include <assert.h>
+
+typedef struct PosixService PosixService;
+
+struct PosixService {
+    ServiceRecordSet coreServ;
+    PosixService *next;
+    int serviceID;
+};
+
+static PosixService *gServiceList = NULL;
+
+static void RegistrationCallback(mDNS *const m, ServiceRecordSet *const thisRegistration, mStatus status)
+    // mDNS core calls this routine to tell us about the status of 
+    // our registration.  The appropriate action to take depends 
+    // entirely on the value of status.
+{
+    switch (status) {
+
+        case mStatus_NoError:      
+            debugf("Callback: %##s Name Registered",   thisRegistration->RR_SRV.resrec.name->c); 
+            // Do nothing; our name was successfully registered.  We may 
+            // get more call backs in the future.
+            break;
+
+        case mStatus_NameConflict: 
+            debugf("Callback: %##s Name Conflict",     thisRegistration->RR_SRV.resrec.name->c); 
+
+            // In the event of a conflict, this sample RegistrationCallback 
+            // just calls mDNS_RenameAndReregisterService to automatically 
+            // pick a new unique name for the service. For a device such as a 
+            // printer, this may be appropriate.  For a device with a user 
+            // interface, and a screen, and a keyboard, the appropriate response 
+            // may be to prompt the user and ask them to choose a new name for 
+            // the service.
+            //
+            // Also, what do we do if mDNS_RenameAndReregisterService returns an 
+            // error.  Right now I have no place to send that error to.
+
+            status = mDNS_RenameAndReregisterService(m, thisRegistration, mDNSNULL);
+            assert(status == mStatus_NoError);
+            break;
+
+        case mStatus_MemFree:      
+            debugf("Callback: %##s Memory Free",       thisRegistration->RR_SRV.resrec.name->c); 
+
+            // When debugging is enabled, make sure that thisRegistration 
+            // is not on our gServiceList.
+
+            #if !defined(NDEBUG)
+                {
+                    PosixService *cursor;
+
+                    cursor = gServiceList;
+                    while (cursor != NULL) {
+                        assert(&cursor->coreServ != thisRegistration);
+                        cursor = cursor->next;
+                    }
+                }
+            #endif
+            free(thisRegistration);
+            break;
+
+        default:                   
+            debugf("Callback: %##s Unknown Status %ld", thisRegistration->RR_SRV.resrec.name->c, status); 
+            break;
+    }
+}
+
+static int gServiceID = 0;
+
+static mDNSBool CheckThatRichTextNameIsUsable(const char *richTextName, mDNSBool printExplanation)
+    // Checks that richTextName is reasonable 
+    // label and, if it isn't and printExplanation is true, prints 
+    // an explanation of why not.
+{    
+    mDNSBool result = mDNStrue;
+    if (result && strlen(richTextName) > 63) {
+        if (printExplanation) {
+            LogMsg("%s: Service name is too long (must be 63 characters or less)\n", 
+                    SERVICES_FILE);
+        }
+        result = mDNSfalse;
+    }
+    if (result && richTextName[0] == 0) {
+        if (printExplanation) {
+            LogMsg("%s: Service name can't be empty\n", SERVICES_FILE);
+        }
+        result = mDNSfalse;
+    }
+    return result;
+}
+
+static mDNSBool CheckThatServiceTypeIsUsable(const char *serviceType, mDNSBool printExplanation)
+    // Checks that serviceType is a reasonable service type 
+    // label and, if it isn't and printExplanation is true, prints 
+    // an explanation of why not.
+{
+    mDNSBool result;
+
+    result = mDNStrue;
+    if (result && strlen(serviceType) > 63) {
+        if (printExplanation) {
+            LogMsg("%s: Service type is too long (must be 63 characters or less)\n", 
+                    SERVICES_FILE);
+        }
+        result = mDNSfalse;
+    }
+    if (result && serviceType[0] == 0) {
+        if (printExplanation) {
+            LogMsg("%s: Service type can't be empty\n", 
+                    SERVICES_FILE);
+        }
+        result = mDNSfalse;
+    }
+    return result;
+}
+
+static mDNSBool CheckThatPortNumberIsUsable(long portNumber, mDNSBool printExplanation)
+    // Checks that portNumber is a reasonable port number
+    // and, if it isn't and printExplanation is true, prints 
+    // an explanation of why not.
+{
+    mDNSBool result;
+
+    result = mDNStrue;
+    if (result && (portNumber <= 0 || portNumber > 65535)) {
+        if (printExplanation) {
+               LogMsg("%s: Port number must be in range 1..65535\n", 
+                    SERVICES_FILE);
+        }
+        result = mDNSfalse;
+    }
+    return result;
+}
+
+static mDNSBool ReadALine(char *buf, size_t bufSize, FILE *fp)
+// Read a line, skipping over any blank lines or lines starting with '#'
+{
+    mDNSBool good, skip;
+    do {
+        good = (fgets(buf, bufSize, fp) != NULL);
+        skip = (good && (buf[0] == '#'));
+    } while (good && skip);
+    if (good)
+    {
+        int     len = strlen( buf);
+        if ( buf[len - 1] == '\r' || buf[len - 1] == '\n')
+            buf[len - 1] = '\0';
+    }
+    return good;
+}
+
+static mStatus RegisterOneService(const char *  richTextName, 
+                                  const char *  serviceType, 
+                                  const char *  serviceDomain, 
+                                  const mDNSu8  text[],
+                                  mDNSu16       textLen,
+                                  long          portNumber)
+{
+    mStatus             status;
+    PosixService *      thisServ;
+    domainlabel         name;
+    domainname          type;
+    domainname          domain;
+    
+    status = mStatus_NoError;
+    thisServ = (PosixService *) malloc(sizeof(*thisServ));
+    if (thisServ == NULL) {
+        status = mStatus_NoMemoryErr;
+    }
+    if (status == mStatus_NoError) {
+        MakeDomainLabelFromLiteralString(&name,  richTextName);
+        MakeDomainNameFromDNSNameString(&type, serviceType);
+        MakeDomainNameFromDNSNameString(&domain, serviceDomain);
+        status = mDNS_RegisterService(&mDNSStorage, &thisServ->coreServ,
+                &name, &type, &domain,              // Name, type, domain
+                NULL, mDNSOpaque16fromIntVal(portNumber),
+                text, textLen,                      // TXT data, length
+                NULL, 0,                            // Subtypes
+                mDNSInterface_Any,                  // Interface ID
+                RegistrationCallback, thisServ, // Callback and context
+                0);                       //  flags
+    }
+    if (status == mStatus_NoError) {
+        thisServ->serviceID = gServiceID;
+        gServiceID += 1;
+
+        thisServ->next = gServiceList;
+        gServiceList = thisServ;
+
+        if (gMDNSPlatformPosixVerboseLevel > 0) {
+            LogMsg("%s: Registered service %d, name '%s', type '%s', port %ld\n", 
+                    SERVICES_FILE, 
+                    thisServ->serviceID, 
+                    richTextName,
+                    serviceType,
+                    portNumber);
+        }
+    } else {
+        if (thisServ != NULL) {
+            free(thisServ);
+        }
+    }
+    return status;
+}
+
+static const char kDefaultServiceDomain[] = "local.";
+
+static mStatus RegisterServicesInFile(const char *filePath)
+{
+    mStatus     status = mStatus_NoError;
+    FILE *      fp = fopen(filePath, "r");
+    int         junk;
+
+    if (fp == NULL) {
+        status = mStatus_UnknownErr;
+    }
+    if (status == mStatus_NoError) {
+        mDNSBool good = mDNStrue;
+        do {
+            int         ch;
+            char name[256];
+            char type[256];
+            const char *dom = kDefaultServiceDomain;
+            char rawText[1024];
+            mDNSu8  text[sizeof(RDataBody)];
+            unsigned int textLen = 0;
+            char port[256];
+
+            // Skip over any blank lines.
+            do ch = fgetc(fp); while ( ch == '\n' || ch == '\r' );
+            if (ch != EOF) good = (ungetc(ch, fp) == ch);
+
+            // Read three lines, check them for validity, and register the service.
+            good = ReadALine(name, sizeof(name), fp);               
+            if (good) {
+                good = ReadALine(type, sizeof(type), fp);
+            }
+            if (good) {
+                char *p = type;
+                while (*p && *p != ' ') p++;
+                if (*p) {
+                    *p = 0;
+                    dom = p+1;
+                }
+            }
+            if (good) {
+                good = ReadALine(port, sizeof(port), fp);
+            }
+            if (good) {
+                good =     CheckThatRichTextNameIsUsable(name, mDNSfalse)
+                        && CheckThatServiceTypeIsUsable(type, mDNSfalse)
+                        && CheckThatPortNumberIsUsable(atol(port), mDNSfalse);
+            }
+            if (good) {
+                while (1) {
+                    int len;
+                    if (!ReadALine(rawText, sizeof(rawText), fp)) break;
+                    len = strlen(rawText);
+                    if (len <= 255)
+                        {
+                        unsigned int newlen = textLen + 1 + len;
+                        if (len == 0 || newlen >= sizeof(text)) break;
+                        text[textLen] = len;
+                        mDNSPlatformMemCopy(text + textLen + 1, rawText, len);
+                        textLen = newlen;
+                        }
+                    else
+                        LogMsg("%s: TXT attribute too long for name = %s, type = %s, port = %s\n", 
+                            SERVICES_FILE, name, type, port);
+                }
+            }
+            if (good) {
+                status = RegisterOneService(name, type, dom, text, textLen, atol(port));
+                if (status != mStatus_NoError) {
+                    LogMsg("%s: Failed to register service, name = %s, type = %s, port = %s\n", 
+                            SERVICES_FILE, name, type, port);
+                    status = mStatus_NoError;       // keep reading
+                }
+            }
+        } while (good && !feof(fp));
+
+        if ( ! good ) {
+            LogMsg("%s: Error reading service file %s\n", SERVICES_FILE, filePath);
+        }
+    }
+
+    if (fp != NULL) {
+        junk = fclose(fp);
+        assert(junk == 0);
+    }
+
+    return status;
+}
+
+static void DeregisterOurServices(void)
+{
+    PosixService *thisServ;
+    int thisServID;
+    
+    while (gServiceList != NULL) {
+        thisServ = gServiceList;
+        gServiceList = thisServ->next;
+
+        thisServID = thisServ->serviceID;
+        
+        mDNS_DeregisterService(&mDNSStorage, &thisServ->coreServ);
+
+        if (gMDNSPlatformPosixVerboseLevel > 0) {
+            LogMsg("%s: Deregistered service %d\n",
+                    SERVICES_FILE, 
+                    thisServ->serviceID);
+        }
+    }
+}
+
 #if _BUILDING_XCODE_PROJECT_
 // If the process crashes, then this string will be magically included in the automatically-generated crash log
 const char *__crashreporter_info__ = mDNSResponderVersionString_SCCS + 5;
diff -rupN mDNSResponder-522.92.1/mDNSPosix/mDNSPosix.c mDNSResponder-522.92.1-Linux/mDNSPosix/mDNSPosix.c
--- mDNSResponder-522.92.1/mDNSPosix/mDNSPosix.c	2013-04-25 16:22:21.000000000 -0700
+++ mDNSResponder-522.92.1-Linux/mDNSPosix/mDNSPosix.c	2014-08-17 13:21:32.000000000 -0700
@@ -50,6 +50,10 @@
 #include <net/if.h>
 #endif // USES_NETLINK
 
+#ifdef TARGET_OS_LINUX
+#include <sys/ioctl.h>
+#endif
+
 #include "mDNSUNP.h"
 #include "GenLinkedList.h"
 
@@ -66,6 +70,19 @@ struct PosixEventSource
 };
 typedef struct PosixEventSource PosixEventSource;
 
+// Platform-dependent low-level networking stuff
+
+mDNSlocal int SetupSocket(struct sockaddr *intfAddr, mDNSIPPort port, int interfaceIndex, int *sktPtr,
+               mDNSIPPort* outport, mDNSBool joinMC);
+mDNSlocal mStatus SetupTCPSocket(TCPSocket *sock, u_short sa_family, mDNSIPPort *port);
+
+mDNSlocal int GetFDTcp(TCPSocket *sock, u_short sa_family);
+
+static struct UDPSocket_struct* PlatformUDPSockets = NULL;
+static struct TCPSocket_struct* PlatformTCPSockets = NULL;
+
+mDNSlocal void DoTcpSocketCallback(TCPSocket *sock);
+
 // Context record for interface change callback
 struct IfChangeRec
 {
@@ -144,7 +161,7 @@ mDNSexport mStatus mDNSPlatformSendUDP(c
     PosixNetworkInterface * thisIntf = (PosixNetworkInterface *)(InterfaceID);
     int sendingsocket = -1;
 
-    (void)src;  // Will need to use this parameter once we implement mDNSPlatformUDPSocket/mDNSPlatformUDPClose
+    //(void)src;  // Will need to use this parameter once we implement mDNSPlatformUDPSocket/mDNSPlatformUDPClose
     (void) useBackgroundTrafficClass;
 
     assert(m != NULL);
@@ -166,7 +183,8 @@ mDNSexport mStatus mDNSPlatformSendUDP(c
         sin->sin_family         = AF_INET;
         sin->sin_port           = dstPort.NotAnInteger;
         sin->sin_addr.s_addr    = dst->ip.v4.NotAnInteger;
-        sendingsocket           = thisIntf ? thisIntf->multicastSocket4 : m->p->unicastSocket4;
+        sendingsocket           = (src) ? (src->sktv4) :
+                                      (thisIntf ? thisIntf->multicastSocket4 : m->p->unicastSocket4);
     }
 
 #if HAVE_IPV6
@@ -180,7 +198,8 @@ mDNSexport mStatus mDNSPlatformSendUDP(c
         sin6->sin6_family         = AF_INET6;
         sin6->sin6_port           = dstPort.NotAnInteger;
         sin6->sin6_addr           = *(struct in6_addr*)&dst->ip.v6;
-        sendingsocket             = thisIntf ? thisIntf->multicastSocket6 : m->p->unicastSocket6;
+        sendingsocket             = (src) ? (src->sktv6) :
+                                      (thisIntf ? thisIntf->multicastSocket6 : m->p->unicastSocket6);
     }
 #endif
 
@@ -210,7 +229,7 @@ mDNSexport mStatus mDNSPlatformSendUDP(c
 }
 
 // This routine is called when the main loop detects that data is available on a socket.
-mDNSlocal void SocketDataReady(mDNS *const m, PosixNetworkInterface *intf, int skt)
+mDNSlocal void SocketDataReady(mDNS *const m, PosixNetworkInterface *intf, int skt, mDNSIPPort localPort)
 {
     mDNSAddr senderAddr, destAddr;
     mDNSIPPort senderPort;
@@ -306,89 +325,477 @@ mDNSlocal void SocketDataReady(mDNS *con
 
     if (packetLen >= 0)
         mDNSCoreReceive(m, &packet, (mDNSu8 *)&packet + packetLen,
-                        &senderAddr, senderPort, &destAddr, MulticastDNSPort, InterfaceID);
+            &senderAddr, senderPort, &destAddr, mDNSIPPortIsZero(localPort) ? MulticastDNSPort : localPort, InterfaceID);
+
 }
 
 mDNSexport mDNSBool mDNSPlatformPeekUDP(mDNS *const m, UDPSocket *src)
 {
     (void)m;    // unused
     (void)src;  // unused
+    LogMsg("%s:%s(): NOT IMPLEMENTED!", __FILE__, __FUNCTION__);
     return mDNSfalse;
 }
 
+mDNSlocal mStatus SetupTCPSocket(TCPSocket *sock, u_short sa_family, mDNSIPPort *port)
+{
+   const int kOn = 1;  // "on" for setsockopt
+   mStatus err;
+
+   int skt = socket(sa_family, SOCK_STREAM, IPPROTO_TCP);
+   if (skt < 3) {
+      LogMsg("SetupTCPSocket: socket error %d errno %d (%s)", skt, errno, strerror(errno));
+      return mStatus_UnsupportedErr;
+   }
+
+   if (sa_family == AF_INET) {
+      // Bind it
+      struct sockaddr_in addr;
+      mDNSPlatformMemZero(&addr, sizeof(addr));
+      addr.sin_family = AF_INET;
+      addr.sin_port = port->NotAnInteger;
+
+      err = bind(skt, (struct sockaddr*) &addr, sizeof(addr));
+      if (err < 0) {
+         LogMsg("ERROR: SetupTCPSocket bind %s", strerror(errno));
+         return err;
+      }
+
+      // Receive interface identifiers
+    #if defined(IP_PKTINFO)                                 // Linux
+            err = setsockopt(skt, IPPROTO_IP, IP_PKTINFO, &kOn, sizeof(kOn));
+            if (err < 0) { err = errno; LogMsg("ERROR: SetupTCPSocket setsockopt - IP_PKTINFO"); }
+        #elif defined(IP_RECVDSTADDR) || defined(IP_RECVIF)     // BSD and Solaris
+            #if defined(IP_RECVDSTADDR)
+                err = setsockopt(skt, IPPROTO_IP, IP_RECVDSTADDR, &kOn, sizeof(kOn));
+                if (err < 0) { err = errno; LogMsg("ERROR: SetupTCPSocket setsockopt - IP_RECVDSTADDR"); }
+            #endif
+            #if defined(IP_RECVIF)
+                if (err == 0) {
+                    err = setsockopt(skt, IPPROTO_IP, IP_RECVIF, &kOn, sizeof(kOn));
+                    if (err < 0) { err = errno; LogMsg("ERROR: SetupTCPSocket setsockopt - IP_RECVIF"); }
+                }
+            #endif
+        #else
+            #warning This platform has no way to get the destination interface information -- will only work for single-homed hosts
+        #endif
+
+      mDNSPlatformMemZero(&addr, sizeof(addr));
+      socklen_t len = sizeof(addr);
+      err = getsockname(skt, (struct sockaddr*) &addr, &len);
+      if (err < 0) {
+         LogMsg("ERROR: SetupTCPSocket getsockname - %s", strerror(errno));
+         return err;
+      }
+
+      sock->sktv4 = skt;
+      port->NotAnInteger = addr.sin_port;
+#if HAVE_IPV6
+   } else {
+      // Bind it
+      struct sockaddr_in6 addr6;
+      mDNSPlatformMemZero(&addr6, sizeof(addr6));
+      addr6.sin6_family = AF_INET6;
+      addr6.sin6_port = port->NotAnInteger;
+
+      err = bind(skt, (struct sockaddr*) &addr6, sizeof(addr6));
+
+      if (err < 0) {
+         LogMsg("ERROR: SetupTCPSocket bind6 %s", strerror(errno));
+         return err;
+      }
+
+      // We want to receive destination addresses and receive interface identifiers
+      err = setsockopt(skt, IPPROTO_IPV6, IPV6_RECVPKTINFO, &kOn, sizeof(kOn));
+      if (err < 0) {
+         LogMsg("ERROR: SetupTCPSocket setsockopt IPV6_RECVPKTINFO %s", strerror(errno));
+         return err;
+      }
+
+      mDNSPlatformMemZero(&addr6, sizeof(addr6));
+      socklen_t len = sizeof(addr6);
+
+      err = getsockname(skt, (struct sockaddr *) &addr6, &len);
+      if (err < 0) {
+         LogMsg("ERROR: SetupTCPSocket getsockname6 - %s", strerror(errno));
+         return err;
+      }
+
+      sock->sktv6 = skt;
+      port->NotAnInteger = addr6.sin6_port;
+#endif
+   }
+
+   return mStatus_NoError;
+}
+
+mDNSlocal void DoTcpSocketCallback(TCPSocket *sock)
+{
+    mDNSBool c = !sock->state.connected;
+    sock->state.connected = 1;
+    sock->callback(sock, sock->context, c, sock->err);
+    // Note: the callback may call CloseConnection here, which frees the context structure!
+}
+
+
 mDNSexport TCPSocket *mDNSPlatformTCPSocket(mDNS * const m, TCPSocketFlags flags, mDNSIPPort * port, mDNSBool useBackgroundTrafficClass)
 {
-    (void)m;            // Unused
-    (void)flags;        // Unused
-    (void)port;         // Unused
-    (void)useBackgroundTrafficClass; // Unused
-    return NULL;
+    mStatus err;
+    
+   (void)m;
+    
+    TCPSocket *p = mallocL("TCPSocket", sizeof(TCPSocket));
+   if (!p) { LogMsg("mDNSPlatformTCPSocket: memory exhausted"); return(mDNSNULL); }
+   
+   mDNSPlatformMemZero(p, sizeof(TCPSocket));
+   p->sktv4 = -1;
+   p->sktv6 = -1;
+   p->activeSkt = -1;
+   
+   err = SetupTCPSocket(p, AF_INET, port);
+   
+#if HAVE_IPV6
+   if (mStatus_NoError == err) {
+      err = SetupTCPSocket(p, AF_INET6, port);
+      if (err) {
+         mDNSPlatformTCPCloseConnection(p);
+         p = NULL;
+      }
+   }
+#endif
+   
+   if (err) {
+      LogMsg("mDNSPlatformTCPSocket: socket error errno %d (%s)", errno, strerror(errno));
+      if (NULL != p)
+         freeL("TCPSocket/mDNSPlatformTCPSocket", p);
+      return(mDNSNULL);
+   }
+   
+   p->flags = flags;
+   
+   p->prev = NULL;
+   p->next = PlatformTCPSockets;
+   if (p->next)
+      p->next->prev = p;
+   PlatformTCPSockets = p;
+   
+   LogMsg("TCPSocket created for port %d, sock %d", port->NotAnInteger, p->sktv4);
+   
+   return p;
 }
 
+// Why doesn't mDNSPlatformTCPAccept actually call accept() ?
+// gck: Exactly what I was wondering too! :-)
 mDNSexport TCPSocket *mDNSPlatformTCPAccept(TCPSocketFlags flags, int sd)
 {
-    (void)flags;        // Unused
-    (void)sd;           // Unused
-    return NULL;
+   mStatus err = mStatus_NoError;
+
+   TCPSocket *sock = mallocL("TCPSocket/mDNSPlatformTCPAccept", sizeof(TCPSocket));
+   if (NULL == sock) {
+      LogMsg("mDNSPlatformTCPAccept: memory exhausted.");
+      return mDNSNULL;
+   }
+
+   mDNSPlatformMemZero(sock, sizeof(*sock));
+   sock->flags = flags;
+   sock->activeSkt = sd;
+   
+   // we need to find out if the connected socket is IPv4 or IPv6, since the
+   // function parameters won't tell us
+   struct sockaddr addr;
+   mDNSPlatformMemZero(&addr, sizeof(addr));
+    socklen_t len = sizeof(addr);
+   err = getsockname(sd, &addr, &len);
+   
+   if (AF_INET == addr.sa_family)
+      sock->sktv4 = sd;
+   else
+      sock->sktv6 = sd;
+
+   if (flags & kTCPSocketFlags_UseTLS) {
+      LogMsg("mDNSPlatformTCPAccept: ERROR kTCPSocketFlags_UseTLS not supported!");
+      err = mStatus_UnsupportedErr;
+   }
+   
+   if (err) {
+      freeL("TCPSocket/mDNSPlatformTCPAccept", sock);
+      sock = mDNSNULL;
+   }
+   
+   return sock;
 }
 
+mDNSlocal int GetFDTcp(TCPSocket *sock, u_short sa_family)
+{
+   return (AF_INET == sa_family) ? sock->sktv4 : sock->sktv6;
+} 
+
 mDNSexport int mDNSPlatformTCPGetFD(TCPSocket *sock)
 {
-    (void)sock;         // Unused
-    return -1;
+   // return the active socket, otherwise, return the IPv4 socket, else return IPv6
+   if (sock->activeSkt > -1)
+      return sock->activeSkt;
+   
+   int fd = GetFDTcp(sock, AF_INET);
+   
+   return (fd > -1) ? fd : GetFDTcp(sock, AF_INET6);
 }
 
-mDNSexport mStatus mDNSPlatformTCPConnect(TCPSocket *sock, const mDNSAddr *dst, mDNSOpaque16 dstport, domainname *hostname, mDNSInterfaceID InterfaceID,
-                                          TCPConnectionCallback callback, void *context)
+mDNSexport mStatus mDNSPlatformTCPConnect(TCPSocket *sock, const mDNSAddr *dst, mDNSOpaque16 dstport, domainname *hostname,
+                        mDNSInterfaceID InterfaceID, TCPConnectionCallback callback, void *context)
 {
-    (void)sock;         // Unused
-    (void)dst;          // Unused
-    (void)dstport;      // Unused
-    (void)hostname;     // Unused
-    (void)InterfaceID;  // Unused
-    (void)callback;     // Unused
-    (void)context;      // Unused
-    return(mStatus_UnsupportedErr);
+    struct sockaddr_storage ss;
+   
+#if HAVE_IPV6
+   int* s = (mDNSAddrType_IPv4 == dst->type) ? &sock->sktv4 : &sock->sktv6;
+#else
+   int* s = &sock->sktv4;
+#endif
+
+    sock->err         = mStatus_NoError;
+   sock->context     = context;
+   sock->callback    = callback;
+   
+   if (sock->state.connected)
+      LogMsg("mDNSPlatformTCPConnect: socket already connected!");
+
+    if (NULL != hostname) {
+       LogMsg("mDNSPlatformTCPConnect: hostname %##s", hostname->c);
+       AssignDomainName(&sock->hostname, hostname);
+    }
+
+    if (dst->type == mDNSAddrType_IPv4) {
+        struct sockaddr_in *saddr = (struct sockaddr_in *)&ss;
+        mDNSPlatformMemZero(saddr, sizeof(*saddr));
+        saddr->sin_family      = AF_INET;
+        saddr->sin_port        = dstport.NotAnInteger;
+        saddr->sin_addr.s_addr = dst->ip.v4.NotAnInteger;
+#ifndef NOT_HAVE_SA_LEN
+        saddr->sin_len         = sizeof(*saddr);
+#endif
+    } else {
+        struct sockaddr_in6 *saddr6 = (struct sockaddr_in6 *)&ss;
+        mDNSPlatformMemZero(saddr6, sizeof(*saddr6));
+        saddr6->sin6_family      = AF_INET6;
+        saddr6->sin6_port        = dstport.NotAnInteger;
+        saddr6->sin6_addr        = *(struct in6_addr *)&dst->ip.v6;
+#ifndef NOT_HAVE_SA_LEN
+        saddr6->sin6_len         = sizeof(*saddr6);
+#endif
+    }
+
+    if (fcntl(*s, F_SETFL, fcntl(*s, F_GETFL, 0) | O_NONBLOCK) < 0) { // set non-blocking
+        LogMsg("mDNSPlatformTCPConnect: ERROR setsockopt O_NONBLOCK - %s", strerror(errno));
+        return mStatus_UnknownErr;
+    }
+
+    // We bind to the interface and all subsequent packets including the SYN will be sent out
+    // on this interface
+    //
+    // Note: If we are in Active Directory domain, we may try TCP (if the response can't fit in
+    // UDP). mDNSInterface_Unicast indicates this case and not a valid interface.
+    if (InterfaceID && InterfaceID != mDNSInterface_Unicast) {
+       PosixNetworkInterface* intf = (PosixNetworkInterface *)(InterfaceID);
+       
+       // gck: SO_BINDTODEVICE is a linux-ism, but that's the only thing I'm concerned about here.
+       struct ifreq ifr;
+      memset(&ifr, 0, sizeof(struct ifreq));
+      strncpy(ifr.ifr_name, intf->intfName, sizeof(ifr.ifr_name));
+      ioctl(*s, SIOCGIFINDEX, &ifr);
+
+      int e = setsockopt(*s, SOL_SOCKET, SO_BINDTODEVICE, (void*)&ifr, sizeof(struct ifreq));
+      LogMsg("mDNSPlatformTCPConnect: binding to device %s returned %d", ifr.ifr_name, e);
+    }
+
+   sock->activeSkt = *s;
+
+   if (connect(*s, (struct sockaddr*)&ss, sizeof(struct sockaddr)) < 0) {
+      switch (errno) {
+         case EINPROGRESS:
+            return mStatus_ConnPending;
+         default:
+            LogMsg("ERROR: mDNSPlatformTCPConnect - connect failed: socket %d: Error %d (%s)", *s, errno, strerror(errno));
+            return mStatus_ConnFailed;
+      }
+   }
+   
+   LogMsg("NOTE: mDNSPlatformTCPConnect completed synchronously");
+   return mStatus_NoError;
 }
 
 mDNSexport void mDNSPlatformTCPCloseConnection(TCPSocket *sock)
 {
-    (void)sock;         // Unused
+   if (sock) {
+      if (sock->activeSkt > -1) close(sock->activeSkt);
+      if (sock->sktv4 > -1) close(sock->sktv4);
+#if HAVE_IPV6
+      if (sock->sktv6 > -1) close(sock->sktv6);
+#endif
+
+      if (sock->prev)
+         sock->prev->next = sock->next;
+      else
+         PlatformTCPSockets = sock->next;
+
+      if (sock->next)
+         sock->next->prev = sock->prev;
+
+      LogMsg("Closed TCP socket %d", sock->sktv4);
+
+      freeL("TCPSocket/mDNSPlatformTCPCloseConnection", sock);
+   }
 }
 
 mDNSexport long mDNSPlatformReadTCP(TCPSocket *sock, void *buf, unsigned long buflen, mDNSBool * closed)
 {
-    (void)sock;         // Unused
-    (void)buf;          // Unused
-    (void)buflen;       // Unused
-    (void)closed;       // Unused
-    return 0;
+   size_t nread = 0;
+   int fd = (sock->activeSkt > -1) ? sock->activeSkt : mDNSPlatformTCPGetFD(sock);
+   
+   if (NULL != closed)
+      *closed = mDNSfalse;
+    
+    if (sock->flags & kTCPSocketFlags_UseTLS) {
+      LogMsg("ERROR: mDNSPlatformReadTCP kTCPSocketFlags_UseTLS not supported!");
+      nread = -1;
+      if (NULL != closed)
+         *closed = mDNStrue;
+    } else {
+      static int CLOSEDcount = 0;
+      static int EAGAINcount = 0;
+      
+      nread = recv(fd, buf, buflen, 0);
+      
+      if (nread > 0) {
+         CLOSEDcount = EAGAINcount = 0;
+      } else if (0 == nread) {
+         if (NULL != closed)
+            *closed = mDNStrue;
+         if ((++CLOSEDcount % 1000) == 0)
+            LogMsg("ERROR: mDNSPlatformReadTCP - recv %d got CLOSED %d times", sock->activeSkt, CLOSEDcount);
+      } else if (ECONNRESET == errno) {   // from here on, nread must be negative
+         nread = 0;
+         if (NULL != closed)
+            *closed = mDNStrue;
+      } else if (EAGAIN == errno) {
+         nread = 0;
+         if ((++EAGAINcount % 1000) == 0)
+            LogMsg("ERROR: mDNSPlatformReadTCP - recv %d got EAGAIN %d times", sock->activeSkt, EAGAINcount);
+      } else {
+         nread = -1;
+         LogMsg("ERROR: mDNSPlatformReadTCP - recv: %d (%s)", errno, strerror(errno));
+      }
+    }
+
+   return nread;
 }
 
 mDNSexport long mDNSPlatformWriteTCP(TCPSocket *sock, const char *msg, unsigned long len)
 {
-    (void)sock;         // Unused
-    (void)msg;          // Unused
-    (void)len;          // Unused
-    return 0;
-}
+   int nsent;
+   int fd = (sock->activeSkt > -1) ? sock->activeSkt : mDNSPlatformTCPGetFD(sock);
 
-mDNSexport UDPSocket *mDNSPlatformUDPSocket(mDNS * const m, mDNSIPPort port)
-{
-    (void)m;            // Unused
-    (void)port;         // Unused
-    return NULL;
+   if (sock->flags & kTCPSocketFlags_UseTLS) {
+      LogMsg("ERROR: mDNSPlatformWriteTCP kTCPSocketFlags_UseTLS not supported!");
+      nsent = -1;
+   } else {
+      nsent = send(fd, msg, len, 0);
+      
+      if (nsent < 0) {
+         if (EAGAIN == errno)
+            nsent = 0;
+         else {
+            LogMsg("ERROR: mDNSPlatformWriteTCP - send %s", strerror(errno));
+            nsent = -1;
+         }
+      }
+   }
+   
+   return nsent;
 }
 
-mDNSexport void           mDNSPlatformUDPClose(UDPSocket *sock)
+mDNSexport UDPSocket *mDNSPlatformUDPSocket(mDNS * const m, mDNSIPPort requestedPort)
 {
-    (void)sock;         // Unused
+    mStatus err;
+    mDNSIPPort port = requestedPort;
+    mDNSBool randomizePort = mDNSIPPortIsZero(requestedPort);
+    struct sockaddr sa;
+    int i = 1000; // Try at most 1000 times to get a unique random port
+    UDPSocket *p = mallocL("UDPSocket", sizeof(UDPSocket));
+    if (!p) { LogMsg("mDNSPlatformUDPSocket: memory exhausted"); return(mDNSNULL); }
+    mDNSPlatformMemZero(p, sizeof(UDPSocket));
+    p->port  = zeroIPPort;
+    p->sktv4 = -1;
+    p->sktv6 = -1;
+
+    (void)m;
+
+    do
+    {
+        // The kernel doesn't do cryptographically strong random port allocation, so we do it ourselves here
+        if (randomizePort) port = mDNSOpaque16fromIntVal(0xC000 + mDNSRandom(0x3FFF));
+        mDNSPlatformMemZero(&sa, sizeof(struct sockaddr));
+        sa.sa_family = AF_INET;
+        err = SetupSocket(&sa, port, 0, &p->sktv4, &p->port, mDNSSameIPPort(requestedPort, NATPMPAnnouncementPort));
+        /* TODO: make me work!
+        if (!err)
+        {
+            mDNSPlatformMemZero(&sa, sizeof(struct sockaddr));
+            sa.sa_family = AF_INET6;
+            err = SetupSocket(&sa, port, 0, &p->sktv6, &p->port, 0);
+            if (err) { close(p->sktv4); p->sktv4 = -1; }
+        }*/
+        i--;
+    } while (err == EADDRINUSE && randomizePort && i);
+
+    if (err)
+    {
+        // In customer builds we don't want to log failures with port 5351, because this is a known issue
+        // of failing to bind to this port when Internet Sharing has already bound to it
+        // We also don't want to log about port 5350, due to a known bug when some other
+        // process is bound to it.
+        if (mDNSSameIPPort(requestedPort, NATPMPPort) || mDNSSameIPPort(requestedPort, NATPMPAnnouncementPort))
+            LogInfo("mDNSPlatformUDPSocket: SetupSocket %d failed error %d errno %d (%s)", mDNSVal16(requestedPort), err, errno, strerror(errno));
+        else LogMsg("mDNSPlatformUDPSocket: SetupSocket %d failed error %d errno %d (%s)", mDNSVal16(requestedPort), err, errno, strerror(errno));
+            freeL("UDPSocket", p);
+            return(mDNSNULL);
+    }
+
+    p->prev = NULL;
+    p->next = PlatformUDPSockets;
+    if (p->next)
+        p->next->prev = p;
+    PlatformUDPSockets = p;
+
+    return(p);
+}
+
+mDNSexport void mDNSPlatformUDPClose(UDPSocket *sock)
+{
+   if (sock->sktv4 > -1) {
+      close(sock->sktv4);
+      sock->sktv4 = -1;
+   }
+   if (sock->sktv6 > -1) {
+      close(sock->sktv6);
+      sock->sktv6 = -1;
+   }
+   
+   if (sock->prev)
+      sock->prev->next = sock->next;
+   else
+      PlatformUDPSockets = sock->next;
+   
+   if (sock->next)
+      sock->next->prev = sock->prev;
+   
+   freeL("UDPSocket", sock);
 }
 
 mDNSexport void mDNSPlatformUpdateProxyList(mDNS *const m, const mDNSInterfaceID InterfaceID)
 {
     (void)m;            // Unused
     (void)InterfaceID;          // Unused
+    LogMsg("%s:%s(): NOT IMPLEMENTED!", __FILE__, __FUNCTION__);
 }
 
 mDNSexport void mDNSPlatformSendRawPacket(const void *const msg, const mDNSu8 *const end, mDNSInterfaceID InterfaceID)
@@ -396,6 +803,7 @@ mDNSexport void mDNSPlatformSendRawPacke
     (void)msg;          // Unused
     (void)end;          // Unused
     (void)InterfaceID;          // Unused
+    LogMsg("%s:%s(): NOT IMPLEMENTED!", __FILE__, __FUNCTION__);
 }
 
 mDNSexport void mDNSPlatformSetLocalAddressCacheEntry(mDNS *const m, const mDNSAddr *const tpa, const mDNSEthAddr *const tha, mDNSInterfaceID InterfaceID)
@@ -404,15 +812,18 @@ mDNSexport void mDNSPlatformSetLocalAddr
     (void)tpa;          // Unused
     (void)tha;          // Unused
     (void)InterfaceID;          // Unused
+    LogMsg("%s:%s(): NOT IMPLEMENTED!", __FILE__, __FUNCTION__);
 }
 
 mDNSexport mStatus mDNSPlatformTLSSetupCerts(void)
 {
+    LogMsg("%s:%s(): NOT IMPLEMENTED!", __FILE__, __FUNCTION__);
     return(mStatus_UnsupportedErr);
 }
 
 mDNSexport void mDNSPlatformTLSTearDownCerts(void)
 {
+    LogMsg("%s:%s(): NOT IMPLEMENTED!", __FILE__, __FUNCTION__);
 }
 
 mDNSexport void mDNSPlatformSetAllowSleep(mDNS *const m, mDNSBool allowSleep, const char *reason)
@@ -420,6 +831,7 @@ mDNSexport void mDNSPlatformSetAllowSlee
     (void) m;
     (void) allowSleep;
     (void) reason;
+    LogMsg("%s:%s(): NOT IMPLEMENTED!", __FILE__, __FUNCTION__);
 }
 
 #if COMPILER_LIKES_PRAGMA_MARK
@@ -453,20 +865,108 @@ mDNSexport mDNSBool mDNSPlatformSetDNSCo
     return mDNStrue;
 }
 
+#ifdef TARGET_OS_LINUX
+#include <ctype.h>
+#endif
+
 mDNSexport mStatus mDNSPlatformGetPrimaryInterface(mDNS * const m, mDNSAddr * v4, mDNSAddr * v6, mDNSAddr * router)
+#ifdef TARGET_OS_LINUX
 {
+   unsigned long d, g;
+   char buf[256];
+   int line = 0;
+   FILE * f;
+   char * p;
+
+   (void)m;
+
+   // TODO: where/how to get ipv6 address?
+   if (v6)
+      *v6 = zeroAddr;
+
+   f = fopen("/proc/net/route", "r");
+
+   if (!f)
+      return mStatus_UnknownErr;
+
+   while(fgets(buf, sizeof(buf), f)) {
+      if(line > 0) {  /* skip the first line */
+         p = buf;
+
+         /* skip the interface name */
+         while(*p && !isspace(*p))
+            p++;
+
+         *p++ = '\0';
+
+         while(*p && isspace(*p))
+            p++;
+
+         if(sscanf(p, "%lx%lx", &d, &g)==2) {
+            if(d == 0 && g != 0) {
+               if (router) {
+                  router->type = mDNSAddrType_IPv4;
+                  router->ip.v4.NotAnInteger = g;
+               }
+               fclose(f);
+               
+               int sock = socket(AF_INET, SOCK_DGRAM, 0);
+               if (sock > -1) {
+                  struct sockaddr_in sin;
+                  socklen_t socklen = sizeof(struct sockaddr_in);
+                  
+                  mDNSPlatformMemZero(&sin, socklen);
+                  sin.sin_port = htons(3000);
+                  sin.sin_addr.s_addr = INADDR_ANY;
+                  sin.sin_family = AF_INET;
+                  
+                  
+                  if (connect(sock, (struct sockaddr*)&sin, socklen) >= 0 &&
+                      getsockname(sock, (struct sockaddr*)&sin, &socklen) >= 0) {
+                     
+                     if (v4) {
+                        v4->type = mDNSAddrType_IPv4;
+                        v4->ip.v4.NotAnInteger = sin.sin_addr.s_addr;
+                     }
+                     
+                     return mStatus_NoError;
+                  }
+                  
+                  close(sock);
+               }
+               
+               return mStatus_UnknownErr;
+            }
+         }
+      }
+
+   line++;
+   }
+
+   /* default route not found ! */
+   if (f)
+      fclose(f);
+
+   return mStatus_UnknownErr;
+}
+#else
+    {
     (void) m;
     (void) v4;
     (void) v6;
     (void) router;
 
+   LogMsg("%s:%s(): NOT IMPLEMENTED!", __FILE__, __FUNCTION__);
+
     return mStatus_UnsupportedErr;
-}
+    }
+#endif
 
 mDNSexport void mDNSPlatformDynDNSHostNameStatusChanged(const domainname *const dname, const mStatus status)
 {
     (void) dname;
     (void) status;
+    LogMsg("%s:%s(): NOT IMPLEMENTED!", __FILE__, __FUNCTION__);
 }
 
 #if COMPILER_LIKES_PRAGMA_MARK
@@ -601,13 +1101,15 @@ mDNSlocal void ClearInterfaceList(mDNS *
 // Sets up a send/receive socket.
 // If mDNSIPPort port is non-zero, then it's a multicast socket on the specified interface
 // If mDNSIPPort port is zero, then it's a randomly assigned port number, used for sending unicast queries
-mDNSlocal int SetupSocket(struct sockaddr *intfAddr, mDNSIPPort port, int interfaceIndex, int *sktPtr)
+mDNSlocal int SetupSocket(struct sockaddr *intfAddr, mDNSIPPort port, int interfaceIndex, int *sktPtr,
+                           mDNSIPPort* outport, mDNSBool joinMC)
 {
     int err = 0;
     static const int kOn = 1;
     static const int kIntTwoFiveFive = 255;
     static const unsigned char kByteTwoFiveFive = 255;
-    const mDNSBool JoinMulticastGroup = (port.NotAnInteger != 0);
+    const mDNSBool JoinMulticastGroup = joinMC; // was: (port.NotAnInteger != 0);
+    const mDNSBool isNATPMPAnnouncePort = mDNSSameIPPort(port, NATPMPAnnouncementPort);
 
     (void) interfaceIndex;  // This parameter unused on plaforms that don't have IPv6
     assert(intfAddr != NULL);
@@ -673,7 +1175,8 @@ mDNSlocal int SetupSocket(struct sockadd
         // Add multicast group membership on this interface
         if (err == 0 && JoinMulticastGroup)
         {
-            imr.imr_multiaddr.s_addr = AllDNSLinkGroup_v4.ip.v4.NotAnInteger;
+            imr.imr_multiaddr.s_addr = isNATPMPAnnouncePort ? AllHosts_v4.NotAnInteger :  
+                                          AllDNSLinkGroup_v4.ip.v4.NotAnInteger;
             imr.imr_interface        = ((struct sockaddr_in*)intfAddr)->sin_addr;
             err = setsockopt(*sktPtr, IPPROTO_IP, IP_ADD_MEMBERSHIP, &imr, sizeof(imr));
             if (err < 0) { err = errno; perror("setsockopt - IP_ADD_MEMBERSHIP"); }
@@ -708,9 +1211,10 @@ mDNSlocal int SetupSocket(struct sockadd
         {
             bindAddr.sin_family      = AF_INET;
             bindAddr.sin_port        = port.NotAnInteger;
-            bindAddr.sin_addr.s_addr = INADDR_ANY; // Want to receive multicasts AND unicasts on this socket
+            bindAddr.sin_addr.s_addr = isNATPMPAnnouncePort ? AllHosts_v4.NotAnInteger : INADDR_ANY; // Want to receive multicasts AND unicasts on this socket
             err = bind(*sktPtr, (struct sockaddr *) &bindAddr, sizeof(bindAddr));
             if (err < 0) { err = errno; perror("bind"); fflush(stderr); }
+            if (outport) outport->NotAnInteger = bindAddr.sin_port;
         }
     }     // endif (intfAddr->sa_family == AF_INET)
 
@@ -875,10 +1379,10 @@ mDNSlocal int SetupOneInterface(mDNS *co
     if (err == 0)
     {
         if (alias->multicastSocket4 == -1 && intfAddr->sa_family == AF_INET)
-            err = SetupSocket(intfAddr, MulticastDNSPort, intf->index, &alias->multicastSocket4);
+            err = SetupSocket(intfAddr, MulticastDNSPort, intf->index, &alias->multicastSocket4, NULL, 1);
 #if HAVE_IPV6
         else if (alias->multicastSocket6 == -1 && intfAddr->sa_family == AF_INET6)
-            err = SetupSocket(intfAddr, MulticastDNSPort, intf->index, &alias->multicastSocket6);
+            err = SetupSocket(intfAddr, MulticastDNSPort, intf->index, &alias->multicastSocket6, NULL, 1);
 #endif
     }
 
@@ -1236,11 +1740,11 @@ mDNSexport mStatus mDNSPlatformInit(mDNS
 
     sa.sa_family = AF_INET;
     m->p->unicastSocket4 = -1;
-    if (err == mStatus_NoError) err = SetupSocket(&sa, zeroIPPort, 0, &m->p->unicastSocket4);
+    if (err == mStatus_NoError) err = SetupSocket(&sa, zeroIPPort, 0, &m->p->unicastSocket4, NULL, 0);
 #if HAVE_IPV6
     sa.sa_family = AF_INET6;
     m->p->unicastSocket6 = -1;
-    if (err == mStatus_NoError) err = SetupSocket(&sa, zeroIPPort, 0, &m->p->unicastSocket6);
+    if (err == mStatus_NoError) err = SetupSocket(&sa, zeroIPPort, 0, &m->p->unicastSocket6, NULL, 0);
 #endif
 
     // Tell mDNS core about the network interfaces on this machine.
@@ -1590,6 +2094,24 @@ mDNSexport void mDNSPosixGetFDSet(mDNS *
         info = (PosixNetworkInterface *)(info->coreIntf.next);
     }
 
+    UDPSocket* udpSock = PlatformUDPSockets;
+    while (udpSock) {
+        if (udpSock->sktv4 > -1) mDNSPosixAddToFDSet(nfds, readfds, udpSock->sktv4);
+#if HAVE_IPV6
+        if (udpSock->sktv6 > -1) mDNSPosixAddToFDSet(nfds, readfds, udpSock->sktv6);
+#endif
+      
+        udpSock = udpSock->next;
+    }
+   
+    TCPSocket* tcpSock = PlatformTCPSockets;
+    while (tcpSock) {
+        int fd = mDNSPlatformTCPGetFD(tcpSock);
+        if (fd > -1) mDNSPosixAddToFDSet(nfds, readfds, fd);
+
+        tcpSock = tcpSock->next;
+    }
+
     // 3. Calculate the time remaining to the next scheduled event (in struct timeval format)
     ticks = nextevent - mDNS_TimeNow(m);
     if (ticks < 1) ticks = 1;
@@ -1612,13 +2134,13 @@ mDNSexport void mDNSPosixProcessFDSet(mD
     if (m->p->unicastSocket4 != -1 && FD_ISSET(m->p->unicastSocket4, readfds))
     {
         FD_CLR(m->p->unicastSocket4, readfds);
-        SocketDataReady(m, NULL, m->p->unicastSocket4);
+        SocketDataReady(m, NULL, m->p->unicastSocket4, zeroIPPort);
     }
 #if HAVE_IPV6
     if (m->p->unicastSocket6 != -1 && FD_ISSET(m->p->unicastSocket6, readfds))
     {
         FD_CLR(m->p->unicastSocket6, readfds);
-        SocketDataReady(m, NULL, m->p->unicastSocket6);
+        SocketDataReady(m, NULL, m->p->unicastSocket6, zeroIPPort);
     }
 #endif
 
@@ -1627,17 +2149,49 @@ mDNSexport void mDNSPosixProcessFDSet(mD
         if (info->multicastSocket4 != -1 && FD_ISSET(info->multicastSocket4, readfds))
         {
             FD_CLR(info->multicastSocket4, readfds);
-            SocketDataReady(m, info, info->multicastSocket4);
+            SocketDataReady(m, info, info->multicastSocket4, zeroIPPort);
         }
 #if HAVE_IPV6
         if (info->multicastSocket6 != -1 && FD_ISSET(info->multicastSocket6, readfds))
         {
             FD_CLR(info->multicastSocket6, readfds);
-            SocketDataReady(m, info, info->multicastSocket6);
+            SocketDataReady(m, info, info->multicastSocket6, zeroIPPort);
         }
 #endif
         info = (PosixNetworkInterface *)(info->coreIntf.next);
     }
+    UDPSocket* udpSock = PlatformUDPSockets;
+    while (udpSock) {
+        if (udpSock->sktv4 > -1 && FD_ISSET(udpSock->sktv4, readfds)) {
+            FD_CLR(udpSock->sktv4, readfds);
+            SocketDataReady(m, NULL, udpSock->sktv4, udpSock->port);
+        }
+#if HAVE_IPV6
+        if (udpSock->sktv6 > -1 && FD_ISSET(udpSock->sktv6, readfds)) {
+            FD_CLR(udpSock->sktv6, readfds);
+            SocketDataReady(m, NULL, udpSock->sktv6, udpSock->port);
+        }
+#endif
+
+        udpSock = udpSock->next;
+    }
+      
+    TCPSocket* tcpSock = PlatformTCPSockets;
+    while (tcpSock) {
+        int fd = mDNSPlatformTCPGetFD(tcpSock);
+        if (fd > -1 && FD_ISSET(fd, readfds)) {
+            FD_CLR(fd, readfds);
+            
+            if (tcpSock->flags & kTCPSocketFlags_UseTLS) {
+               LogMsg("ERROR: mDNSPosixProcessFDSet kTCPSocketFlags_UseTLS not supported!");
+               tcpSock->err = mStatus_UnsupportedErr;
+            }
+            
+            DoTcpSocketCallback(tcpSock);
+        }
+
+        tcpSock = tcpSock->next;
+    }
 }
 
 // update gMaxFD
@@ -1778,3 +2332,70 @@ mStatus mDNSPosixRunEventLoopOnce(mDNS *
 
     return mStatus_NoError;
 }
+
+#ifdef TARGET_OS_LINUX
+int mDNS_PlatformGetGateway(const char* ifname, mDNSAddr* v4, mDNSAddr* v6)
+{
+    unsigned long d, g;
+    char buf[256];
+    int line = 0;
+    FILE * f;
+    char * p;
+
+    // TODO: how to get v6 address?
+    if (v6)
+        *v6 = zeroAddr;
+
+    f = fopen("/proc/net/route", "r");
+
+    if (!f)
+        return mStatus_UnknownErr;
+
+    while(fgets(buf, sizeof(buf), f)) {
+        if(line > 0) {  /* skip the first line */
+            p = buf;
+
+            /* skip the interface name */
+            while(*p && !isspace(*p))
+                p++;
+
+            if (ifname) {
+                *p = '\0';
+                if (strcmp(ifname, buf))
+                    continue;
+                else
+                    *p = ' ';
+            }
+
+            while(*p && isspace(*p))
+                p++;
+
+            // TODO: how to actually get the router address if it's NOT the
+            // default route (e.g. 0.0.0.0)
+            if(sscanf(p, "%lx%lx", &d, &g)==2) {
+                if(d == 0 && g != 0) { /* default */
+                    if (v4) {
+                        v4->type = mDNSAddrType_IPv4;
+                        v4->ip.v4.NotAnInteger = g;
+                    }
+                    fclose(f);
+                    return mStatus_NoError;
+                }
+            }
+        }
+
+    line++;
+    }
+
+    /* default route not found ! */
+    if (f)
+        fclose(f);
+
+return mStatus_UnknownErr;
+}
+#else
+int mDNS_PlatformGetGateway(const char* ifname, in_addr_t * addr)
+{
+    return -1;
+}
+#endif
diff -rupN mDNSResponder-522.92.1/mDNSPosix/mDNSPosix.h mDNSResponder-522.92.1-Linux/mDNSPosix/mDNSPosix.h
--- mDNSResponder-522.92.1/mDNSPosix/mDNSPosix.h	2011-12-01 16:39:45.000000000 -0800
+++ mDNSResponder-522.92.1-Linux/mDNSPosix/mDNSPosix.h	2014-08-17 13:21:32.000000000 -0700
@@ -56,6 +56,36 @@ struct mDNS_PlatformSupport_struct
 #endif
 };
 
+// Platform-specific low-level networking code
+
+struct UDPSocket_struct {
+  mDNSIPPort port;
+  int sktv4;
+  int sktv6;
+  
+  struct UDPSocket_struct* next;
+  struct UDPSocket_struct* prev;
+};
+
+struct TCPSocket_struct {
+   TCPSocketFlags flags; // MUST BE FIRST FIELD -- mDNSCore expects every TCPSocket_struct to begin with TCPSocketFlags flags
+   int sktv4;
+   int sktv6;
+   int activeSkt;
+   
+   mStatus                 err;
+   domainname              hostname;
+   TCPConnectionCallback   callback;
+   void*                   context;
+   
+   struct	{
+       unsigned connected:1;
+   } state;
+   
+   struct TCPSocket_struct* next;
+   struct TCPSocket_struct* prev;
+};
+
 #define uDNS_SERVERS_FILE "/etc/resolv.conf"
 extern int ParseDNSServers(mDNS *m, const char *filePath);
 extern mStatus mDNSPlatformPosixRefreshInterfaceList(mDNS *const m);
@@ -78,6 +108,8 @@ extern mStatus mDNSPosixListenForSignalI
 extern mStatus mDNSPosixIgnoreSignalInEventLoop( int signum);
 extern mStatus mDNSPosixRunEventLoopOnce( mDNS *m, const struct timeval *pTimeout, sigset_t *pSignalsReceived, mDNSBool *pDataDispatched);
 
+int mDNS_PlatformGetGateway(const char* ifname, mDNSAddr* v4, mDNSAddr* v6);
+
 #ifdef  __cplusplus
 }
 #endif
diff -rupN mDNSResponder-522.92.1/mDNSShared/PlatformCommon.c mDNSResponder-522.92.1-Linux/mDNSShared/PlatformCommon.c
--- mDNSResponder-522.92.1/mDNSShared/PlatformCommon.c	2012-06-29 21:52:35.000000000 -0700
+++ mDNSResponder-522.92.1-Linux/mDNSShared/PlatformCommon.c	2014-08-17 13:21:32.000000000 -0700
@@ -21,6 +21,7 @@
 #include <errno.h>              // Needed for errno etc.
 #include <sys/socket.h>         // Needed for socket() etc.
 #include <netinet/in.h>         // Needed for sockaddr_in
+#include <stdlib.h>             // Needed for strtol()
 #include <syslog.h>
 
 #include "mDNSEmbeddedAPI.h"    // Defines the interface provided to the client layer above
@@ -102,20 +103,32 @@ mDNSlocal mDNSBool GetConfigOption(char 
 mDNSexport void ReadDDNSSettingsFromConfFile(mDNS *const m, const char *const filename, domainname *const hostname, domainname *const domain, mDNSBool *DomainDiscoveryDisabled)
 {
     char buf[MAX_ESCAPED_DOMAIN_NAME] = "";
+    char knn[MAX_ESCAPED_DOMAIN_NAME] = "";
+    domainname keyName;
+    mDNSIPPort port;
+    keyName.c[0] = knn[0] = 0;
+
     mStatus err;
     FILE *f = fopen(filename, "r");
 
     if (hostname) hostname->c[0] = 0;
     if (domain) domain->c[0] = 0;
     if (DomainDiscoveryDisabled) *DomainDiscoveryDisabled = mDNSfalse;
+    
+    port = UnicastDNSPort;
 
     if (f)
     {
         if (DomainDiscoveryDisabled && GetConfigOption(buf, "DomainDiscoveryDisabled", f) && !strcasecmp(buf, "true")) *DomainDiscoveryDisabled = mDNStrue;
         if (hostname && GetConfigOption(buf, "hostname", f) && !MakeDomainNameFromDNSNameString(hostname, buf)) goto badf;
         if (domain && GetConfigOption(buf, "zone", f) && !MakeDomainNameFromDNSNameString(domain, buf)) goto badf;
+        if (GetConfigOption(buf, "port", f)) {
+            port = mDNSOpaque16fromIntVal(strtol(buf, (char **)NULL, 10));
+        }
         buf[0] = 0;
         GetConfigOption(buf, "secret-64", f);  // failure means no authentication
+        if (GetConfigOption(knn, "secret-name", f))
+            MakeDomainNameFromDNSNameString(&keyName, knn);
         fclose(f);
         f = NULL;
     }
@@ -129,7 +142,7 @@ mDNSexport void ReadDDNSSettingsFromConf
     {
         DomainAuthInfo *info = (DomainAuthInfo*)mDNSPlatformMemAllocate(sizeof(*info));
         // for now we assume keyname = service reg domain and we use same key for service and hostname registration
-        err = mDNS_SetSecretForDomain(m, info, domain, domain, buf, NULL, 0, mDNSfalse);
+        err = mDNS_SetSecretForDomain(m, info, domain, (keyName.c[0] ? &keyName : domain), buf, hostname, &port, NULL);
         if (err) LogMsg("ERROR: mDNS_SetSecretForDomain returned %d for domain %##s", err, domain->c);
     }
 
diff -rupN mDNSResponder-522.92.1/mDNSShared/dnsextd.c mDNSResponder-522.92.1-Linux/mDNSShared/dnsextd.c
--- mDNSResponder-522.92.1/mDNSShared/dnsextd.c	2013-04-25 16:22:21.000000000 -0700
+++ mDNSResponder-522.92.1-Linux/mDNSShared/dnsextd.c	2014-08-17 13:21:32.000000000 -0700
@@ -1240,8 +1240,8 @@ SetupSockets
 
     // set up socket on which we receive private requests
 
-    self->llq_tcpsd = socket( AF_INET, SOCK_STREAM, 0 );
-    require_action( dnssd_SocketValid(self->tlssd), exit, err = mStatus_UnknownErr; LogErr( "SetupSockets", "socket" ) );
+    //self->llq_tcpsd = socket( AF_INET, SOCK_STREAM, 0 );
+    //require_action( dnssd_SocketValid(self->tlssd), exit, err = mStatus_UnknownErr; LogErr( "SetupSockets", "socket" ) );
     mDNSPlatformMemZero(&daddr, sizeof(daddr));
     daddr.sin_family        = AF_INET;
     daddr.sin_addr.s_addr   = zerov4Addr.NotAnInteger;
diff -rupN mDNSResponder-522.92.1/mDNSShared/dnsextd_parser.y mDNSResponder-522.92.1-Linux/mDNSShared/dnsextd_parser.y
--- mDNSResponder-522.92.1/mDNSShared/dnsextd_parser.y	2010-03-17 13:26:12.000000000 -0700
+++ mDNSResponder-522.92.1-Linux/mDNSShared/dnsextd_parser.y	2014-08-17 13:21:32.000000000 -0700
@@ -74,6 +74,7 @@ typedef struct ZoneSpec
 	struct ZoneSpec	*	next;
 } ZoneSpec;
 
+int yydebug=0; // gck
 
 static StringListElem	*	g_stringList = NULL;
 static KeySpec			*	g_keys;
@@ -150,7 +151,7 @@ command:
 options_set:
 		OPTIONS optionscontent
 		{
-			// SetupOptions( &g_optionsInfo, context );
+			//SetupOptions( &g_optionsInfo, context );
 		}
 		;
 
@@ -281,7 +282,7 @@ zonestatement:
 		}
 		|
 		ALLOWUPDATE keycontent
-		{
+		{		
 			g_zoneSpec.allowUpdate = g_stringList;
 			g_stringList = NULL;
 		}
@@ -325,7 +326,7 @@ keystatements:
 		;
 
 keystatement:
-		KEY DOMAINNAME
+		KEY QUOTEDSTRING
 		{
 			StringListElem * elem;
 
